Project Path: /home/tlh/gui-fab-fict

Source Tree:

```
gui-fab-fict
├── utils
│   ├── __pycache__
│   │   ├── logger.cpython-312.pyc
│   │   ├── config.cpython-312.pyc
│   │   └── file_handler.cpython-312.pyc
│   ├── config.py
│   ├── file_handler.py
│   └── logger.py
├── requirements.txt
├── main.py
├── data
│   ├── Testing.json
│   ├── cam girlo.json
│   ├── Occult Infidelity.json
│   └── Cheater's Punishment.json
├── core
│   ├── __pycache__
│   │   ├── book_spec.cpython-312.pyc
│   │   ├── project_manager.cpython-312.pyc
│   │   ├── content_generator.cpython-312.pyc
│   │   └── plot_outline.cpython-312.pyc
│   ├── content_generator.py
│   ├── book_spec.py
│   ├── plot_outline.py
│   └── project_manager.py
├── streamli_app.py
└── llm
    ├── __pycache__
    │   ├── llm_client.cpython-312.pyc
    │   └── prompt_manager.cpython-312.pyc
    ├── llm_client.py
    └── prompt_manager.py

```

`/home/tlh/gui-fab-fict/utils/config.py`:

```````py
# utils/config.py
import os

from dotenv import load_dotenv

load_dotenv()


class Config:
    """
    Configuration manager for the Fiction Fabricator application.

    Loads configurations from environment variables and provides access
    to them through getter methods. Uses a singleton pattern to ensure
    only one configuration instance exists throughout the application.
    """

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Config, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        """
        Initializes the configuration by loading environment variables.
        """
        self.project_directory = os.getenv("PROJECT_DIRECTORY", "data")
        self.log_level = os.getenv("LOG_LEVEL", "INFO").upper()
        self.ollama_model_name = os.getenv("OLLAMA_MODEL_NAME", "llama2")


    def get_project_directory(self) -> str:
        """
        Returns the configured project directory.

        Returns:
            str: The directory where project data will be stored.
        """
        return self.project_directory

    def get_log_level(self) -> str:
        """
        Returns the configured log level.

        Returns:
            str: The log level for the application (e.g., "DEBUG", "INFO", "WARNING").
        """
        return self.log_level

    def get_ollama_model_name(self) -> str:
        """
        Returns the configured Ollama model name.

        Returns:
            str: The name of the Ollama model to be used.
        """
        return self.ollama_model_name

    def set_ollama_model_name(self, model_name: str) -> None:
        """
        Sets the configured Ollama model name.

        Args:
            str: The name of the Ollama model to be used.
        """
        self.ollama_model_name = model_name


# Instantiate the Config singleton
config = Config()
```````

`/home/tlh/gui-fab-fict/utils/file_handler.py`:

```````py
# fiction_fabricator/src/utils/file_handler.py
import json
import os

from utils.logger import logger


def save_json(data: dict, filepath: str) -> None:
    """
    Saves data to a JSON file.

    Args:
        data (dict): The data to be saved as JSON.
        filepath (str): The path to the file where the JSON data will be saved.
    """
    try:
        # Ensure directory exists
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, "w") as f:
            json.dump(data, f, indent=4)
        logger.info(f"JSON data saved to: {filepath}")
    except Exception as e:
        logger.error(f"Error saving JSON to {filepath}: {e}")
        raise


def load_json(filepath: str) -> dict:
    """
    Loads data from a JSON file.

    Args:
        filepath (str): The path to the JSON file to be loaded.

    Returns:
        dict: The data loaded from the JSON file.

    Raises:
        FileNotFoundError: If the specified file does not exist.
        JSONDecodeError: If the file content is not valid JSON.
        Exception: For other potential file reading errors.
    """
    try:
        with open(filepath, "r") as f:
            data = json.load(f)
        logger.info(f"JSON data loaded from: {filepath}")
        return data
    except FileNotFoundError:
        logger.error(f"JSON file not found: {filepath}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding JSON from {filepath}: {e}")
        raise
    except Exception as e:
        logger.error(f"Error loading JSON from {filepath}: {e}")
        raise


def save_markdown(text: str, filepath: str) -> None:
    """
    Saves text content to a Markdown file.

    Args:
        text (str): The text content to be saved in Markdown format.
        filepath (str): The path to the file where the Markdown content will be saved.
    """
    try:
        # Ensure directory exists
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, "w") as f:
            f.write(text)
        logger.info(f"Markdown content saved to: {filepath}")
    except Exception as e:
        logger.error(f"Error saving Markdown to {filepath}: {e}")
        raise
```````

`/home/tlh/gui-fab-fict/utils/logger.py`:

```````py
# fiction_fabricator/src/utils/logger.py
import logging
import sys

from  utils.config import config


def setup_logger() -> logging.Logger:
    """
    Sets up and configures a logger for the Fiction Fabricator application.

    The logger outputs to the console and its log level is determined by the
    'LOG_LEVEL' configuration parameter.

    Returns:
        logging.Logger: A configured logger instance.
    """
    logger = logging.getLogger(__name__)
    log_level_str = config.get_log_level()

    log_levels = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
    }

    log_level = log_levels.get(log_level_str, logging.INFO)
    logger.setLevel(log_level)

    # Create console handler
    console_handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(module)s - %(message)s"
    )
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    return logger


logger = setup_logger()
```````

`/home/tlh/gui-fab-fict/requirements.txt`:

```````txt
streamlit
ollama
pydantic
python-dotenv
black
pytest
sphinx
mypy
requests
tiktoken
```````

`/home/tlh/gui-fab-fict/main.py`:

```````py

# fiction_fabricator/main.py
import argparse

from  core.project_manager import ProjectManager
from utils.logger import logger


def main():
    """
    Main function for the Fiction Fabricator command-line interface.

    Provides basic command-line access to project management functionalities.
    Currently supports loading and saving projects.
    """
    parser = argparse.ArgumentParser(description="Fiction Fabricator CLI")
    subparsers = parser.add_subparsers(title="commands", dest="command")

    # Save project command
    save_parser = subparsers.add_parser("save", help="Save a project")
    save_parser.add_argument("project_name", help="Name of the project to save")

    # Load project command
    load_parser = subparsers.add_parser("load", help="Load a project")
    load_parser.add_argument("project_name", help="Name of the project to load")

    args = parser.parse_args()

    project_manager = ProjectManager()

    if args.command == "save":
        try:
            # In a real CLI, you would likely load project data into memory first,
            # but for this basic example, we'll just indicate the save action.
            # A more complete CLI would load the current project state from a file or memory.
            project_manager.save_project(args.project_name, book_spec=None) # BookSpec needs to be loaded or passed in a real CLI
            logger.info(f"Project '{args.project_name}' save command executed (data handling not fully implemented in CLI).")
            print(f"Project '{args.project_name}' save command executed (data handling not fully implemented in CLI).")
        except Exception as e:
            logger.error(f"Error saving project from CLI: {e}")
            print(f"Error saving project: {e}")

    elif args.command == "load":
        try:
            project_data = project_manager.load_project(args.project_name)
            if project_data:
                logger.info(f"Project '{args.project_name}' loaded via CLI.")
                print(f"Project '{args.project_name}' loaded successfully (data loaded but not displayed in CLI).")
                # In a real CLI, you might process or display the loaded data here.
            else:
                logger.warning(f"Project '{args.project_name}' not loaded or not found via CLI.")
                print(f"Project '{args.project_name}' not loaded or not found.")
        except Exception as e:
            logger.error(f"Error loading project from CLI: {e}")
            print(f"Error loading project: {e}")

    elif args.command is None:
        parser.print_help()


if __name__ == "__main__":
    main()
```````

`/home/tlh/gui-fab-fict/data/Testing.json`:

```````json
{
    "book_spec": null,
    "plot_outline": null,
    "chapter_outlines": null,
    "scene_outlines": null,
    "scene_parts": null
}
```````

`/home/tlh/gui-fab-fict/data/cam girlo.json`:

```````json
{
    "book_spec": null,
    "plot_outline": null,
    "chapter_outlines": null,
    "scene_outlines": null,
    "scene_parts": null
}
```````

`/home/tlh/gui-fab-fict/data/Occult Infidelity.json`:

```````json
{
    "book_spec": null,
    "plot_outline": null,
    "chapter_outlines": null,
    "scene_outlines": null,
    "scene_parts": null
}
```````

`/home/tlh/gui-fab-fict/data/Cheater's Punishment.json`:

```````json
{
    "book_spec": null,
    "plot_outline": null,
    "chapter_outlines": null,
    "scene_outlines": null,
    "scene_parts": null
}
```````

`/home/tlh/gui-fab-fict/core/content_generator.py`:

```````py
# core/content_generator.py
import json
from typing import List

from core.book_spec import BookSpec
from core.plot_outline import ChapterOutline, PlotOutline, SceneOutline
from llm.llm_client import OllamaClient
from llm.prompt_manager import PromptManager
from utils.logger import logger
from pydantic import ValidationError
from utils.config import config


class ContentGenerator:
    """
    Orchestrates the content generation process for the novel.

    This class uses the OllamaClient to interact with the LLM and the PromptManager
    to generate prompts for each stage of content creation, from book specification
    to scene parts. It handles the generation, enhancement, and user interaction
    workflow for creating the novel's content.
    """

    def __init__(self, llm_client: OllamaClient, prompt_manager: PromptManager):
        """
        Initializes the ContentGenerator with an LLM client and a prompt manager.

        Args:
            llm_client (OllamaClient): The Ollama client instance for interacting with the LLM.
            prompt_manager (PromptManager): The PromptManager instance for generating prompts.
        """
        self.llm_client = llm_client
        self.prompt_manager = prompt_manager

    def generate_book_spec(self, idea: str) -> BookSpec | None:
        """
        Generates a BookSpec object based on a user-provided story idea.

        Uses the PromptManager to create a book specification prompt and the OllamaClient
        to generate the book specification text. Parses the generated text into a BookSpec object.

        Args:
            idea (str): The user's initial story idea.

        Returns:
            BookSpec | None: A BookSpec object if generation is successful, None otherwise.
        """
        prompt = self.prompt_manager.create_book_spec_prompt(idea)
        generated_text = self.llm_client.generate_text(config.ollama_model_name, prompt)
        if generated_text:
            try:
                book_spec_data = json.loads(generated_text)
                book_spec = BookSpec(**book_spec_data)
                logger.info("Book specification generated successfully.")
                return book_spec
            except json.JSONDecodeError as e:
                logger.error(f"Error decoding JSON response for BookSpec: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
            except ValidationError as e:
                logger.error(f"Error validating BookSpec: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
            except Exception as e:
                logger.error(f"Unexpected error processing BookSpec response: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def enhance_book_spec(self, current_spec: BookSpec) -> BookSpec | None:
        """
        Enhances an existing BookSpec object using the LLM.

        Uses the PromptManager to create an enhancement prompt and the OllamaClient
        to generate enhanced book specification text. Parses the enhanced text into a BookSpec object.

        Args:
            current_spec (BookSpec): The current BookSpec object to be enhanced.

        Returns:
            BookSpec | None: An enhanced BookSpec object if successful, None otherwise.
        """
        prompt = self.prompt_manager.create_enhance_book_spec_prompt(current_spec)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            try:
                book_spec_data = json.loads(generated_text)
                enhanced_spec = BookSpec(**book_spec_data)
                logger.info("Book specification enhanced successfully.")
                return enhanced_spec
            except json.JSONDecodeError as e:
                logger.error(f"Error decoding JSON response for enhanced BookSpec: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
            except ValidationError as e:
                logger.error(f"Error validating enhanced BookSpec: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
            except Exception as e:
                logger.error(f"Unexpected error processing enhanced BookSpec response: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def generate_plot_outline(self, book_spec: BookSpec) -> PlotOutline | None:
        """
        Generates a PlotOutline object based on a BookSpec.

        Uses the PromptManager to create a plot outline prompt and the OllamaClient
        to generate the plot outline text. Parses the generated text into a PlotOutline object.

        Args:
            book_spec (BookSpec): The BookSpec object to base the plot outline on.

        Returns:
            PlotOutline | None: A PlotOutline object if successful, None otherwise.
        """
        prompt = self.prompt_manager.create_plot_outline_prompt(book_spec)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            try:
                plot_outline = PlotOutline(act_one="", act_two="", act_three="")
                acts = generated_text.split("Act ")
                if len(acts) >= 4:
                    plot_outline.act_one = acts[1].split("Act")[0].strip()
                    plot_outline.act_two = acts[2].split("Act")[0].strip()
                    plot_outline.act_three = acts[3].strip()
                else:
                    logger.warning("Unexpected plot outline format from LLM, basic parsing failed.")
                    plot_outline.act_one = generated_text

                logger.info("Plot outline generated successfully.")
                return plot_outline
            except Exception as e:
                logger.error(f"Error processing PlotOutline response: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def enhance_plot_outline(self, current_outline: str) -> PlotOutline | None:
        """
        Enhances an existing plot outline using the LLM.

        Uses the PromptManager to create an enhancement prompt and the OllamaClient
        to generate enhanced plot outline text. Parses the enhanced text into a PlotOutline object.

        Args:
            current_outline (str): The current plot outline text to be enhanced.

        Returns:
            PlotOutline | None: An enhanced PlotOutline object if successful, None otherwise.
        """
        prompt = self.prompt_manager.create_enhance_plot_outline_prompt(current_outline)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            try:
                plot_outline = PlotOutline(act_one="", act_two="", act_three="")
                acts = generated_text.split("Act ")
                if len(acts) >= 4:
                    plot_outline.act_one = acts[1].split("Act")[0].strip()
                    plot_outline.act_two = acts[2].split("Act")[0].strip()
                    plot_outline.act_three = acts[3].strip()
                else:
                    logger.warning("Unexpected enhanced plot outline format from LLM, basic parsing failed.")
                    plot_outline.act_one = generated_text

                logger.info("Plot outline enhanced successfully.")
                return plot_outline
            except Exception as e:
                logger.error(f"Error processing enhanced PlotOutline response: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def generate_chapter_outlines(self, plot_outline: PlotOutline, num_chapters: int) -> List[ChapterOutline] | None:
        """
        Generates chapter outlines based on a PlotOutline and the desired number of chapters.

        Uses the PromptManager to create a chapter outlines prompt and the OllamaClient
        to generate the chapter outlines text. Parses the generated text into a list of ChapterOutline objects.

        Args:
            plot_outline (PlotOutline): The PlotOutline object to base chapter outlines on.
            num_chapters (int): The desired number of chapters.

        Returns:
            List[ChapterOutline] | None: A list of ChapterOutline objects if successful, None otherwise.
        """
        plot_outline_text = "\n".join([
            "Act One:\n" + plot_outline.act_one,
            "Act Two:\n" + plot_outline.act_two,
            "Act Three:\n" + plot_outline.act_three
        ])
        prompt = self.prompt_manager.create_chapter_outlines_prompt(plot_outline_text, num_chapters)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            chapter_outlines = []
            try:
                chapter_splits = generated_text.strip().split("Chapter ")
                for i, chapter_text in enumerate(chapter_splits[1:], start=1):
                    chapter_summary = chapter_text.split("Chapter")[0].strip()
                    chapter_outlines.append(ChapterOutline(chapter_number=i, summary=chapter_summary))
                logger.info(f"{len(chapter_outlines)} chapter outlines generated successfully.")
                return chapter_outlines
            except Exception as e:
                logger.error(f"Error processing ChapterOutline responses: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def enhance_chapter_outlines(self, current_outlines: List[ChapterOutline]) -> List[ChapterOutline] | None:
        """
        Enhances existing chapter outlines using the LLM.

        Uses the PromptManager to create an enhancement prompt and the OllamaClient
        to generate enhanced chapter outlines text. Parses the enhanced text into a list of ChapterOutline objects.

        Args:
            current_outlines (List[ChapterOutline]): The current list of ChapterOutline objects to be enhanced.

        Returns:
            List[ChapterOutline] | None: An enhanced list of ChapterOutline objects if successful, None otherwise.
        """
        outline_texts = [f"Chapter {co.chapter_number}:\n{co.summary}" for co in current_outlines]
        prompt = self.prompt_manager.create_enhance_chapter_outlines_prompt(outline_texts)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            enhanced_chapter_outlines = []
            try:
                chapter_splits = generated_text.strip().split("Chapter ")
                for i, chapter_text in enumerate(chapter_splits[1:], start=1):
                    chapter_summary = chapter_text.split("Chapter")[0].strip()
                    enhanced_chapter_outlines.append(ChapterOutline(chapter_number=i, summary=chapter_summary))
                logger.info("Chapter outlines enhanced successfully.")
                return enhanced_chapter_outlines
            except Exception as e:
                logger.error(f"Error processing enhanced ChapterOutline responses: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def generate_scene_outlines(self, chapter_outline: ChapterOutline, num_scenes_per_chapter: int) -> List[SceneOutline] | None:
        """
        Generates scene outlines for a given chapter outline and desired number of scenes per chapter.

        Uses the PromptManager to create a scene outlines prompt and the OllamaClient
        to generate the scene outlines text. Parses the generated text into a list of SceneOutline objects.

        Args:
            chapter_outline (ChapterOutline): The ChapterOutline object to base scene outlines on.
            num_scenes_per_chapter (int): The desired number of scenes per chapter.

        Returns:
            List[SceneOutline] | None: A list of SceneOutline objects if successful, None otherwise.
        """
        prompt = self.prompt_manager.create_scene_outlines_prompt(chapter_outline.summary, num_scenes_per_chapter)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            scene_outlines = []
            try:
                scene_splits = generated_text.strip().split("Scene ")
                for i, scene_text in enumerate(scene_splits[1:], start=1):
                    scene_summary = scene_text.split("Scene")[0].strip()
                    scene_outlines.append(SceneOutline(scene_number=i, summary=scene_summary))
                logger.info(f"{len(scene_outlines)} scene outlines generated for chapter {chapter_outline.chapter_number} successfully.")
                return scene_outlines
            except Exception as e:
                logger.error(f"Error processing SceneOutline responses: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def enhance_scene_outlines(self, current_outlines: List[SceneOutline]) -> List[SceneOutline] | None:
        """
        Enhances existing scene outlines using the LLM.

        Uses the PromptManager to create an enhancement prompt and the OllamaClient
        to generate enhanced scene outlines text. Parses the enhanced text into a list of SceneOutline objects.

        Args:
            current_outlines (List[SceneOutline]): The current list of SceneOutline objects to be enhanced.

        Returns:
            List[SceneOutline] | None: An enhanced list of SceneOutline objects if successful, None otherwise.
        """
        outline_texts = [f"Scene {so.scene_number}:\n{so.summary}" for so in current_outlines]
        prompt = self.prompt_manager.create_enhance_scene_outlines_prompt(outline_texts)
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            enhanced_scene_outlines = []
            try:
                scene_splits = generated_text.strip().split("Scene ")
                for i, scene_text in enumerate(scene_splits[1:], start=1):
                    scene_summary = scene_text.split("Scene")[0].strip()
                    enhanced_scene_outlines.append(SceneOutline(scene_number=i, summary=scene_summary))
                logger.info("Scene outlines enhanced successfully.")
                return enhanced_scene_outlines
            except Exception as e:
                logger.error(f"Error processing enhanced SceneOutline responses: {e}")
                logger.debug(f"Raw LLM response: {generated_text}")
        return None

    def generate_scene_part(
        self, scene_outline: SceneOutline, part_number: int, book_spec: BookSpec, chapter_outline: ChapterOutline, scene_outline_full: SceneOutline
    ) -> str | None:
        """
        Generates a part of a scene's text content using the LLM.

        Uses the PromptManager to create a scene part prompt and the OllamaClient
        to generate the text content for that part of the scene.

        Args:
            scene_outline (SceneOutline): The SceneOutline object for the current scene part.
            part_number (int): The part number of the scene (e.g., 1, 2, 3).
            book_spec (BookSpec): The BookSpec object for overall context.
            chapter_outline (ChapterOutline): The ChapterOutline object for chapter context.
            scene_outline_full (SceneOutline): The full SceneOutline object for scene context.

        Returns:
            str | None: The generated text content for the scene part if successful, None otherwise.
        """
        prompt = self.prompt_manager.create_scene_part_prompt(
            scene_outline.summary, part_number, book_spec, chapter_outline.summary, scene_outline_full.summary
        )
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            logger.info("Scene part %d generated successfully.", part_number)
            return generated_text
        return None

    def enhance_scene_part(
        self, scene_part: str, part_number: int, book_spec: BookSpec, chapter_outline: ChapterOutline, scene_outline_full: SceneOutline
    ) -> str | None:
        """
        Enhances an existing scene part's text content using the LLM.

        Uses the PromptManager to create an enhancement prompt and the OllamaClient
        to generate enhanced text content for the scene part.

        Args:
            scene_part (str): The current text content of the scene part.
            part_number (int): The part number of the scene.
            book_spec (BookSpec): The BookSpec object for overall context.
            chapter_outline (ChapterOutline): The ChapterOutline object for chapter context.
            scene_outline_full (SceneOutline): The full SceneOutline object for scene context.

        Returns:
            str | None: The enhanced text content for the scene part if successful, None otherwise.
        """
        prompt = self.prompt_manager.create_enhance_scene_part_prompt(
            scene_part, part_number, book_spec, chapter_outline.summary, scene_outline_full.summary
        )
        generated_text = self.llm_client.generate_text(config.get_ollama_model_name(), prompt)
        if generated_text:
            logger.info("Scene part %d enhanced successfully.", part_number)
            return generated_text
        return None
```````

`/home/tlh/gui-fab-fict/core/book_spec.py`:

```````py
# fiction_fabricator/src/core/book_spec.py
from typing import List

from pydantic import BaseModel


class BookSpec(BaseModel):
    """
    Represents the specification for a novel.

    This Pydantic model defines the structure for storing and validating
    the book specification, including title, genre, setting, themes, tone,
    point of view, characters, and premise.
    """

    title: str
    """The title of the novel."""
    genre: str
    """The genre and subgenres of the novel (e.g., Dark Fantasy, Erotic Thriller)."""
    setting: str
    """Detailed description of the novel's setting(s), including location and time period."""
    themes: List[str]
    """List of major themes explored in the novel, particularly dark and erotic themes."""
    tone: str
    """The overall tone of the novel (e.g., gritty, suspenseful, sensual, melancholic)."""
    point_of_view: str
    """The narrative point of view (e.g., first-person, third-person limited, third-person omniscient)."""
    characters: List[str]
    """Detailed descriptions of 2-3 main characters, including motivations and flaws related to dark and erotic elements."""
    premise: str
    """A concise and intriguing premise that sets up the central conflict and hints at the dark and erotic nature of the story."""
```````

`/home/tlh/gui-fab-fict/core/plot_outline.py`:

```````py
# fiction_fabricator/src/core/plot_outline.py
from typing import List

from pydantic import BaseModel


class PlotOutline(BaseModel):
    """
    Represents a three-act plot outline for a novel.

    This Pydantic model defines the structure for storing the three acts
    of a plot outline: Act One (Setup), Act Two (Confrontation), and
    Act Three (Resolution). Each act is represented as a string containing
    a summary of the plot points within that act.
    """

    act_one: str
    """Summary of Act One: Setup - Introduction of characters, setting, and initial conflict."""
    act_two: str
    """Summary of Act Two: Confrontation - Development of conflict, rising stakes, and obstacles."""
    act_three: str
    """Summary of Act Three: Resolution - Climax, resolution of conflict, and thematic closure."""


class ChapterOutline(BaseModel):
    """
    Represents an outline for a single chapter in the novel.

    This Pydantic model defines the structure for a chapter outline,
    including the chapter number and a summary of the chapter's events.
    """

    chapter_number: int
    """The chapter number (e.g., 1, 2, 3...)."""
    summary: str
    """A summary of the key events and developments within this chapter."""


class SceneOutline(BaseModel):
    """
    Represents an outline for a single scene within a chapter.

    This Pydantic model defines the structure for a scene outline,
    including the scene number and a summary of the scene's events,
    setting, and characters involved.
    """

    scene_number: int
    """The scene number within the chapter (e.g., 1, 2, 3...)."""
    summary: str
    """A summary of the key events, setting, and characters in this scene."""
```````

`/home/tlh/gui-fab-fict/core/project_manager.py`:

```````py
# fiction_fabricator/src/core/project_manager.py
import json
import os

from core.book_spec import BookSpec
from  core.plot_outline import ChapterOutline, PlotOutline, SceneOutline
from  utils.file_handler import load_json, save_json
from  utils.logger import logger


class ProjectManager:
    """
    Manages project loading, saving, and state persistence for the Fiction Fabricator.

    This class handles saving project data to JSON files and loading project data
    from JSON files, allowing users to save their progress and resume work later.
    It supports saving and loading BookSpec, PlotOutline, ChapterOutlines, and
    SceneOutlines.
    """

    def __init__(self, project_dir: str = "data"):
        """
        Initializes the ProjectManager with a specified project directory.

        Args:
            project_dir (str): The directory where project files will be saved and loaded.
                               Defaults to "data" in the project root.
        """
        self.project_dir = project_dir
        os.makedirs(self.project_dir, exist_ok=True)  # Ensure project directory exists

    def save_project(self, project_name: str, book_spec: BookSpec, plot_outline: PlotOutline = None, chapter_outlines: list[ChapterOutline] = None, scene_outlines: dict[int, list[SceneOutline]] = None, scene_parts: dict[int, dict[int, dict[int, str]]] = None) -> None:
        """
        Saves the current project state to a JSON file.

        Saves BookSpec, PlotOutline, ChapterOutlines, and SceneOutlines into a JSON file
        within the project directory. The filename is derived from the project name.

        Args:
            project_name (str): The name of the project, used to create the filename.
            book_spec (BookSpec): The BookSpec object for the project.
            plot_outline (PlotOutline, optional): The PlotOutline object. Defaults to None.
            chapter_outlines (list[ChapterOutline], optional): List of ChapterOutline objects. Defaults to None.
            scene_outlines (dict[int, list[SceneOutline]], optional): Dictionary of scene outlines, keyed by chapter number. Defaults to None.
            scene_parts (dict[int, dict[int, dict[int, str]]], optional): Dictionary of scene parts, keyed by chapter, scene, and part number. Defaults to None.
        """
        if not project_name:
            raise ValueError("Project name cannot be empty for saving.")
        filepath = os.path.join(self.project_dir, f"{project_name}.json")
        project_data = {
            "book_spec": book_spec.dict() if book_spec else None,
            "plot_outline": plot_outline.dict() if plot_outline else None,
            "chapter_outlines": [co.dict() for co in chapter_outlines] if chapter_outlines else None,
            "scene_outlines": {chap_num: [so.dict() for so in scene_list] for chap_num, scene_list in scene_outlines.items()} if scene_outlines else None,
            "scene_parts": scene_parts if scene_parts else None,
        }
        try:
            save_json(project_data, filepath)
            logger.info("Project '%s' saved to: %s", project_name, filepath)
        except Exception as e:
            logger.error("Error saving project '%s': %s", project_name, e)
            raise

    def load_project(self, project_name: str) -> dict | None:
        """
        Loads project data from a JSON file.

        Loads and reconstructs BookSpec, PlotOutline, ChapterOutlines, and SceneOutlines
        from a JSON file within the project directory.

        Args:
            project_name (str): The name of the project to load.

        Returns:
            dict | None: A dictionary containing project data if loading is successful, None otherwise.
                         The dictionary will contain keys: 'book_spec', 'plot_outline', 'chapter_outlines', 'scene_outlines', 'scene_parts',
                         with corresponding objects or None if not saved.
        """
        filepath = os.path.join(self.project_dir, f"{project_name}.json")
        try:
            project_data_raw = load_json(filepath)
            if not project_data_raw:
                logger.warning(f"No data loaded from project file: {filepath}")
                return None

            project_data = {}
            project_data['book_spec'] = BookSpec(**project_data_raw.get('book_spec')) if project_data_raw.get('book_spec') else None
            project_data['plot_outline'] = PlotOutline(**project_data_raw.get('plot_outline')) if project_data_raw.get('plot_outline') else None
            project_data['chapter_outlines'] = [ChapterOutline(**co_data) for co_data in project_data_raw.get('chapter_outlines', [])] if project_data_raw.get('chapter_outlines') else None
            project_data['scene_outlines'] = {int(chap_num): [SceneOutline(**so_data) for so_data in scene_list] for chap_num, scene_list in project_data_raw.get('scene_outlines', {}).items()} if project_data_raw.get('scene_outlines') else None
            project_data['scene_parts'] = project_data_raw.get('scene_parts') if project_data_raw.get('scene_parts') else None

            logger.info(f"Project '{project_name}' loaded from: {filepath}")
            return project_data
        except FileNotFoundError:
            logger.error(f"Project file not found: {filepath}")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding project JSON file {filepath}: {e}")
            return None
        except Exception as e:
            logger.error(f"Error loading project '{project_name}' from {filepath}: {e}")
            return None
```````

`/home/tlh/gui-fab-fict/streamli_app.py`:

```````py
import streamlit as st
import json
from typing import List

from core.book_spec import BookSpec
from core.plot_outline import ChapterOutline, PlotOutline, SceneOutline
from core.content_generator import ContentGenerator
from core.project_manager import ProjectManager
from llm.llm_client import OllamaClient
from llm.prompt_manager import PromptManager
from utils.config import config
from utils.logger import logger
from pydantic import ValidationError


def main():
    """
    Main function to run the Streamlit Fiction Fabricator application.

    Sets up the Streamlit interface, handles user interactions, and orchestrates
    the novel generation process using backend modules.
    """
    st.title("Fiction Fabricator")

    # Initialize session state variables
    if "ollama_client" not in st.session_state:
        st.session_state.ollama_client = OllamaClient()
    if "prompt_manager" not in st.session_state:
        st.session_state.prompt_manager = PromptManager()
    if "content_generator" not in st.session_state:
        st.session_state.content_generator = ContentGenerator(
            st.session_state.ollama_client, st.session_state.prompt_manager
        )
    if "project_manager" not in st.session_state:
        st.session_state.project_manager = ProjectManager()
    if "available_models" not in st.session_state:
        st.session_state.available_models = st.session_state.ollama_client.list_models() or []
    if "selected_model" not in st.session_state:
        st.session_state.selected_model = config.get_ollama_model_name()
    if "story_idea" not in st.session_state:
        st.session_state.story_idea = ""
    if "book_spec" not in st.session_state:
        st.session_state.book_spec = None
    if "plot_outline" not in st.session_state:
        st.session_state.plot_outline = None
    if "chapter_outlines" not in st.session_state:
        st.session_state.chapter_outlines = None
    if "scene_outlines" not in st.session_state:
        st.session_state.scene_outlines = {}
    if "scene_parts" not in st.session_state:
        st.session_state.scene_parts = {}
    if "project_name" not in st.session_state:
        st.session_state.project_name = ""
    if "num_chapters" not in st.session_state:
        st.session_state.num_chapters = 10
    if "num_scenes_per_chapter" not in st.session_state:
        st.session_state.num_scenes_per_chapter = 3

    # --- Sidebar for Settings and Project Management ---
    with st.sidebar:
        st.header("Settings & Project")

        # Model Selection
        model_options = st.session_state.available_models
        if not model_options:
            st.warning("No models found on local Ollama instance. Ensure Ollama is running and models are pulled.")
            model_options = [st.session_state.selected_model]
        st.session_state.selected_model = st.selectbox(
            "Select Ollama Model",
            model_options,
            index=model_options.index(st.session_state.selected_model) if st.session_state.selected_model in model_options else 0,
        )

        st.sidebar.subheader("Project Management") # Fixed the error here using st.sidebar.subheader
        st.session_state.project_name = st.text_input("Project Name", st.session_state.project_name)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("Save Project"):
                if st.session_state.project_name:
                    try:
                        st.session_state.project_manager.save_project(
                            st.session_state.project_name,
                            st.session_state.book_spec,
                            st.session_state.plot_outline,
                            st.session_state.chapter_outlines,
                            st.session_state.scene_outlines,
                            st.session_state.scene_parts,
                        )
                        st.success(f"Project '{st.session_state.project_name}' saved!")
                    except Exception as e:
                        st.error(f"Error saving project: {e}")
                else:
                    st.warning("Please enter a project name to save.")
        with col2:
            if st.button("Load Project"):
                if st.session_state.project_name:
                    try:
                        loaded_data = st.session_state.project_manager.load_project(st.session_state.project_name)
                        if loaded_data:
                            st.session_state.book_spec = loaded_data.get('book_spec')
                            st.session_state.plot_outline = loaded_data.get('plot_outline')
                            st.session_state.chapter_outlines = loaded_data.get('chapter_outlines')
                            st.session_state.scene_outlines = loaded_data.get('scene_outlines')
                            st.session_state.scene_parts = loaded_data.get('scene_parts')
                            st.success(f"Project '{st.session_state.project_name}' loaded!")
                        else:
                            st.warning(f"No project data loaded for '{st.session_state.project_name}'.")
                    except FileNotFoundError:
                        st.error(f"Project file '{st.session_state.project_name}.json' not found.")
                    except Exception as e:
                        st.error(f"Error loading project: {e}")
                else:
                    st.warning("Please enter a project name to load.")

    # --- Main Panel for Content Generation Workflow ---
    st.header("Novel Generation Workflow")

    # 1. Story Idea Input
    st.subheader("1. Story Idea")
    st.session_state.story_idea = st.text_area("Enter your story idea:", value=st.session_state.story_idea, height=100)
    if st.button("Generate Book Specification", disabled=not st.session_state.story_idea):
        with st.spinner("Generating Book Specification..."):
            st.session_state.prompt_manager.book_spec = None
            st.session_state.prompt_manager.book_spec = BookSpec(**st.session_state.book_spec.dict()) if st.session_state.book_spec else None
            st.session_state.book_spec = st.session_state.content_generator.generate_book_spec(st.session_state.story_idea)
        if st.session_state.book_spec:
            st.success("Book Specification Generated!")
        else:
            st.error("Failed to generate Book Specification.")

    # 2. Book Specification Display and Edit
    if st.session_state.book_spec:
        st.subheader("2. Book Specification")
        with st.form("book_spec_form"):
            st.session_state.book_spec.title = st.text_input("Title", st.session_state.book_spec.title)
            st.session_state.book_spec.genre = st.text_input("Genre", st.session_state.book_spec.genre)
            st.session_state.book_spec.setting = st.text_area("Setting", st.session_state.book_spec.setting, height=100)
            st.session_state.book_spec.themes = [theme.strip() for theme in st.text_input("Themes (comma-separated)", ", ".join(st.session_state.book_spec.themes)).split(",")]
            st.session_state.book_spec.tone = st.text_input("Tone", st.session_state.book_spec.tone)
            st.session_state.book_spec.point_of_view = st.text_input("Point of View", st.session_state.book_spec.point_of_view)
            st.session_state.book_spec.characters = [char.strip() for char in st.text_area("Characters (comma-separated descriptions)", "\n".join(st.session_state.book_spec.characters), height=150).split("\n")]
            st.session_state.book_spec.premise = st.text_area("Premise", st.session_state.book_spec.premise, height=100)
            col1, col2 = st.columns([3, 1])
            with col1:
                st.form_submit_button("Save Book Specification")

            with col2:
               if st.form_submit_button("Enhance Book Specification", on_click=None, disabled=False):
                   with st.spinner("Enhancing Book Specification..."):
                       enhanced_spec = st.session_state.content_generator.enhance_book_spec(st.session_state.book_spec)
                       if enhanced_spec:
                           st.session_state.book_spec = enhanced_spec
                           st.success("Book Specification Enhanced!")
                       else:
                           st.error("Failed to enhance Book Specification.")

        st.json(st.session_state.book_spec.dict())

    # 3. Plot Outline Generation and Edit
    if st.session_state.book_spec:
        st.subheader("3. Plot Outline")
        if st.button("Generate Plot Outline", disabled=st.session_state.plot_outline is not None):
            with st.spinner("Generating Plot Outline..."):
                st.session_state.plot_outline = st.session_state.content_generator.generate_plot_outline(st.session_state.book_spec)
            if st.session_state.plot_outline:
                st.success("Plot Outline Generated!")
            else:
                 st.error("Failed to generate Plot Outline.")

        if st.session_state.plot_outline:
            with st.form("plot_outline_form"):
                st.session_state.plot_outline.act_one = st.text_area("Act One: Setup", st.session_state.plot_outline.act_one, height=150)
                st.session_state.plot_outline.act_two = st.text_area("Act Two: Confrontation", st.session_state.plot_outline.act_two, height=200)
                st.session_state.plot_outline.act_three = st.text_area("Act Three: Resolution", st.session_state.plot_outline.act_three, height=150)
                col1, col2 = st.columns([3, 1])
                with col1:
                    st.form_submit_button("Save Plot Outline")
                with col2:
                    if st.form_submit_button("Enhance Plot Outline"):
                        with st.spinner("Enhancing Plot Outline..."):
                            enhanced_outline_raw = st.session_state.content_generator.enhance_plot_outline(
                                "\n".join([
                                    "Act One:\n" + st.session_state.plot_outline.act_one,
                                    "Act Two:\n" + st.session_state.plot_outline.act_two,
                                    "Act Three:\n" + st.session_state.plot_outline.act_three
                                ])
                            )
                            if enhanced_outline_raw:
                                st.session_state.plot_outline = enhanced_outline_raw
                                st.success("Plot Outline Enhanced!")
                            else:
                                st.error("Failed to enhance Plot Outline.")
            st.write("Plot Outline:")
            st.text(
                f"Act One: {st.session_state.plot_outline.act_one}\n\n"
                f"Act Two: {st.session_state.plot_outline.act_two}\n\n"
                f"Act Three: {st.session_state.plot_outline.act_three}"
            )

    # 4. Chapter Outline Generation and Edit
    if st.session_state.plot_outline:
        st.subheader("4. Chapter Outlines")
        num_chapters_input = st.number_input("Number of Chapters:", min_value=3, max_value=50, value=st.session_state.num_chapters, step=1)
        st.session_state.num_chapters = int(num_chapters_input)
        if st.button("Generate Chapter Outlines", disabled=st.session_state.chapter_outlines is not None):
            with st.spinner("Generating Chapter Outlines..."):
                st.session_state.chapter_outlines = st.session_state.content_generator.generate_chapter_outlines(
                    st.session_state.plot_outline, st.session_state.num_chapters
                )
            if st.session_state.chapter_outlines:
                 st.success("Chapter Outlines Generated!")
            else:
                st.error("Failed to generate Chapter Outlines.")

        if st.session_state.chapter_outlines:
            with st.form("chapter_outlines_form"):
                edited_chapter_outlines = []
                for i, chapter_outline in enumerate(st.session_state.chapter_outlines):
                    edited_summary = st.text_area(f"Chapter {i+1} Outline", chapter_outline.summary, height=100, key=f"chapter_{i}_outline")
                    edited_chapter_outlines.append(ChapterOutline(chapter_number=i+1, summary=edited_summary))
                st.session_state.chapter_outlines = edited_chapter_outlines

                col1, col2 = st.columns([3, 1])
                with col1:
                    st.form_submit_button("Save Chapter Outlines")
                with col2:
                    if st.form_submit_button("Enhance Chapter Outlines"):
                         with st.spinner("Enhancing Chapter Outlines..."):
                            enhanced_chapter_outlines = st.session_state.content_generator.enhance_chapter_outlines(
                                st.session_state.chapter_outlines
                            )
                            if enhanced_chapter_outlines:
                                st.session_state.chapter_outlines = enhanced_chapter_outlines
                                st.success("Chapter Outlines Enhanced!")
                            else:
                                st.error("Failed to enhance Chapter Outlines.")

            if st.session_state.chapter_outlines:
                st.write("Chapter Outlines:")
                for chapter_outline in st.session_state.chapter_outlines:
                    st.markdown(f"**Chapter {chapter_outline.chapter_number}:**")
                    st.text(chapter_outline.summary)

    # 5. Scene Outline Generation and Edit (First Chapter only for now - expandable later)
    if st.session_state.chapter_outlines:
        st.subheader("5. Scene Outlines (Chapter 1)")
        num_scenes_input = st.number_input("Scenes per Chapter 1:", min_value=1, max_value=10, value=st.session_state.num_scenes_per_chapter, step=1)
        st.session_state.num_scenes_per_chapter = int(num_scenes_input)

        chapter_one_outline = st.session_state.chapter_outlines[0]

        if st.button("Generate Scene Outlines (Chapter 1)", disabled=st.session_state.scene_outlines.get(1) is not None):
            with st.spinner("Generating Scene Outlines for Chapter 1..."):
                scene_outlines_chapter_1 = st.session_state.content_generator.generate_scene_outlines(
                    chapter_one_outline, st.session_state.num_scenes_per_chapter
                )
                if scene_outlines_chapter_1:
                    st.session_state.scene_outlines[1] = scene_outlines_chapter_1
                    st.success("Scene Outlines Generated for Chapter 1!")
                else:
                    st.error("Failed to generate Scene Outlines for Chapter 1.")

        if st.session_state.scene_outlines.get(1):
            with st.form("scene_outlines_chapter_1_form"):
                edited_scene_outlines_chapter_1 = []
                for i, scene_outline in enumerate(st.session_state.scene_outlines[1]):
                    edited_summary = st.text_area(f"Scene {i+1} Outline", scene_outline.summary, height=80, key=f"scene_1_{i}_outline")
                    edited_scene_outlines_chapter_1.append(SceneOutline(scene_number=i+1, summary=edited_summary))
                st.session_state.scene_outlines[1] = edited_scene_outlines_chapter_1

                col1, col2 = st.columns([3, 1])
                with col1:
                     st.form_submit_button("Save Scene Outlines (Chapter 1)")
                with col2:
                     if st.form_submit_button("Enhance Scene Outlines (Chapter 1)"):
                        with st.spinner("Enhancing Scene Outlines for Chapter 1..."):
                            enhanced_scene_outlines_chapter_1 = st.session_state.content_generator.enhance_scene_outlines(
                                st.session_state.scene_outlines[1]
                            )
                            if enhanced_scene_outlines_chapter_1:
                                st.session_state.scene_outlines[1] = enhanced_scene_outlines_chapter_1
                                st.success("Scene Outlines Enhanced for Chapter 1!")
                            else:
                                st.error("Failed to enhance Scene Outlines for Chapter 1.")

            if st.session_state.scene_outlines.get(1):
                st.write("Scene Outlines for Chapter 1:")
                for scene_outline in st.session_state.scene_outlines[1]:
                    st.markdown(f"**Scene {scene_outline.scene_number}:**")
                    st.text(scene_outline.summary)


if __name__ == "__main__":
    main()
```````

`/home/tlh/gui-fab-fict/llm/llm_client.py`:

```````py
# fiction_fabricator/src/llm/llm_client.py
import json
import requests

from utils.config import config
from utils.logger import logger


class OllamaClient:
    """
    Client for interacting with a local Ollama instance.

    Handles communication with the Ollama API for model listing and text generation.
    """

    def __init__(self, base_url: str = "http://localhost:11434"):
        """
        Initializes the Ollama client.

        Args:
            base_url (str): The base URL of the Ollama API. Defaults to "http://localhost:11434".
        """
        self.base_url = base_url.rstrip("/")  # Remove trailing slash if present

    def list_models(self) -> list[str] | None:
        """
        Fetches the list of available models from the Ollama instance.

        Returns:
            list[str] | None: A list of model names if successful, None otherwise.
        """
        url = f"{self.base_url}/api/tags"
        try:
            response = requests.get(url)
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            models_data = response.json()
            model_names = [model["name"] for model in models_data["models"]]
            logger.info(f"Successfully fetched models: {model_names}")
            return model_names
        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching model list from Ollama: {e}")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding JSON response when listing models: {e}")
            return None

    def generate_text(self, model_name: str, prompt: str) -> str | None:
        """
        Generates text using the specified Ollama model and prompt.

        Args:
            model_name (str): The name of the Ollama model to use.
            prompt (str): The prompt for text generation.

        Returns:
            str | None: The generated text if successful, None otherwise.
        """
        url = f"{self.base_url}/api/generate\ -d"
        data = {
            "model": model_name,
            "prompt": prompt,
            "stream": False,
        }  # stream: False for single response
        try:
            response = requests.post(url, json=data)
            response.raise_for_status()
            response_json = response.json()
            generated_text = response_json.get("response")
            if generated_text:
                logger.info(f"Text generated successfully using model '{model_name}'")
                return generated_text
            else:
                logger.error(
                    f"No 'response' field found in Ollama API response: {response_json}"
                )
                return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Error generating text with Ollama: {e}")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding JSON response when generating text: {e}")
            return None

```````

`/home/tlh/gui-fab-fict/llm/prompt_manager.py`:

```````py
# fiction_fabricator/src/llm/prompt_manager.py
from core.book_spec import BookSpec
from utils.logger import logger


class PromptManager:
    """
    Manages prompt creation for different stages of the novel generation process.

    This class provides methods to generate prompts for creating book specifications,
    plot outlines, chapter outlines, scene outlines, and scene parts. It also includes
    methods for enhancing existing content. Prompts are designed to guide the LLM
    to generate creative and relevant content, emphasizing dark and erotic elements
    as per user requirements.
    """

    def __init__(self, book_spec: BookSpec = None):
        """
        Initializes the PromptManager.

        Args:
            book_spec (BookSpec, optional): An initial BookSpec object to provide context. Defaults to None.
        """
        self.book_spec = book_spec

    def create_book_spec_prompt(self, idea: str) -> str:
        """
        Generates a prompt for creating a book specification based on a user-provided idea.

        Emphasizes dark and erotic elements in the generated book specification.

        Args:
            idea (str): The user's initial story idea.

        Returns:
            str: The generated prompt for book specification creation.
        """
        prompt = f"""
        Generate a detailed book specification for a novel based on the following idea: "{idea}".

        The novel should have a strong focus on dark and erotic themes.

        Include the following elements in the book specification:
        - Title (Compelling and evocative)
        - Genre (Specify the genre and subgenres)
        - Setting(s) (Detailed description of locations and time period)
        - Themes (List of major themes explored in the novel, focusing on dark and erotic aspects)
        - Tone (Describe the overall tone of the novel - e.g., gritty, suspenseful, melancholic, sensual)
        - Point of View (Specify the narrative perspective - e.g., first-person, third-person limited, third-person omniscient)
        - Characters (Detailed descriptions of 2-3 main characters, including their motivations and flaws, especially related to dark and erotic elements)
        - Premise (A concise and intriguing premise that sets up the central conflict and hints at the dark and erotic nature of the story)

        Ensure the book specification is well-structured, creative, and clearly reflects the dark and erotic focus.
        """
        logger.debug(f"Generated book spec prompt: {prompt}")
        return prompt

    def create_enhance_book_spec_prompt(self, current_spec: BookSpec) -> str:
        """
        Generates a prompt to enhance an existing BookSpec object.

        Asks the LLM to refine and expand upon the existing book specification,
        further emphasizing dark and erotic elements and ensuring coherence.

        Args:
            current_spec (BookSpec): The current BookSpec object to be enhanced.

        Returns:
            str: The generated prompt for enhancing the book specification.
        """
        spec_text = current_spec.json(indent=4)
        prompt = f"""
        Enhance the following book specification to make it more compelling, detailed, and cohesive, while maintaining and strengthening its dark and erotic themes.

        Current Book Specification:
        ```json
        {spec_text}
        ```

        Refine and expand upon each section, focusing on:
        - Adding more specific details to the setting, themes, characters, and premise.
        - Ensuring all elements are consistent and contribute to a strong, unified vision for a dark and erotic novel.
        - Enriching character descriptions with deeper psychological insights and motivations related to the dark and erotic aspects of the story.
        - Strengthening the premise to be even more intriguing and suggestive of the novel's nature.
        - Improving the overall flow and readability of the book specification.

        Output should be a complete, enhanced book specification in the same JSON format.
        """
        logger.debug(f"Generated enhance book spec prompt: {prompt}")
        return prompt

    def create_plot_outline_prompt(self, book_spec: BookSpec) -> str:
        """
        Generates a prompt to create a three-act plot outline based on the BookSpec.

        The plot outline should translate the book specification into a structured narrative,
        maintaining the dark and erotic themes and focusing on creating compelling conflict
        and character arcs within a three-act structure.

        Args:
            book_spec (BookSpec): The BookSpec object guiding the plot outline creation.

        Returns:
            str: The generated prompt for plot outline creation.
        """
        spec_text = book_spec.json(indent=4)
        prompt = f"""
        Create a three-act plot outline for a novel based on the following book specification.

        Book Specification:
        ```json
        {spec_text}
        ```

        The plot outline should be structured in three acts:
        - Act One: Setup - Introduce the characters, setting, and premise. Establish the initial conflict and the protagonist's goals.
        - Act Two: Confrontation - Develop the central conflict, raise the stakes, introduce obstacles and challenges for the protagonist. Explore the dark and erotic themes through plot events and character interactions.
        - Act Three: Resolution - Climax of the story, resolution of the main conflict, and thematic closure. Address the consequences of the dark and erotic elements explored throughout the novel.

        The plot outline should be detailed enough to provide a clear roadmap for writing the novel, with specific plot points and character developments in each act. Ensure the outline effectively incorporates and develops the dark and erotic themes from the book specification.
        """
        logger.debug(f"Generated plot outline prompt: {prompt}")
        return prompt

    def create_enhance_plot_outline_prompt(self, current_outline: str) -> str:
        """
        Generates a prompt to enhance an existing plot outline.

        Asks the LLM to refine and expand upon the existing plot outline, ensuring
        it is detailed, well-structured, and effectively develops the dark and erotic
        themes from the book specification.

        Args:
            current_outline (str): The current plot outline text to be enhanced.

        Returns:
            str: The generated prompt for enhancing the plot outline.
        """
        prompt = f"""
        Enhance the following three-act plot outline to make it more detailed, compelling, and structurally sound, while ensuring it effectively develops the dark and erotic themes of the novel.

        Current Plot Outline:
        ```
        {current_outline}
        ```

        Refine and expand upon each act, focusing on:
        - Adding more specific plot points and events within each act.
        - Strengthening the cause-and-effect relationships between plot points.
        - Ensuring a clear progression of conflict and rising stakes throughout the three acts.
        - Deepening the integration of dark and erotic themes into the plot events and character actions.
        - Checking for pacing and narrative flow, ensuring a compelling and engaging structure.
        - Ensuring the resolution in Act Three is satisfying and thematically resonant with the dark and erotic elements explored in the novel.

        Output should be a complete, enhanced three-act plot outline in text format, clearly divided into Act One, Act Two, and Act Three.
        """
        logger.debug(f"Generated enhance plot outline prompt: {prompt}")
        return prompt

    def create_chapter_outlines_prompt(self, plot_outline: str, num_chapters: int) -> str:
        """
        Generates a prompt to create chapter outlines based on the plot outline.

        Divides the three-act plot outline into a specified number of chapters,
        creating a brief outline for each chapter that advances the plot and maintains
        the thematic focus, especially the dark and erotic elements.

        Args:
            plot_outline (str): The three-act plot outline.
            num_chapters (int): The desired number of chapters for the novel.

        Returns:
            str: The generated prompt for chapter outline creation.
        """
        prompt = f"""
        Based on the following three-act plot outline, create detailed outlines for {num_chapters} chapters. Divide the plot events roughly equally across the chapters, ensuring a logical flow and pacing.

        Plot Outline:
        ```
        {plot_outline}
        ```

        For each chapter, provide a concise outline (2-3 paragraphs) summarizing the key events and developments that occur within that chapter. The chapter outlines should:
        - Clearly advance the overall plot as described in the three-act outline.
        - Maintain the established tone and themes, especially the dark and erotic elements.
        - Create anticipation for subsequent chapters and maintain reader engagement.
        - Be numbered sequentially (Chapter 1, Chapter 2, etc.).

        Ensure the chapter outlines collectively cover the entire plot outline and provide a solid structure for writing the full novel.
        """
        logger.debug(f"Generated chapter outlines prompt: {prompt}")
        return prompt

    def create_enhance_chapter_outlines_prompt(self, current_outlines: list[str]) -> str:
        """
        Generates a prompt to enhance existing chapter outlines.

        Refines and expands upon the existing chapter outlines, ensuring they are detailed,
        logically connected, and effectively contribute to the overall plot and thematic
        development, particularly the dark and erotic aspects.

        Args:
            current_outlines (list[str]): A list of current chapter outline texts.

        Returns:
            str: The generated prompt for enhancing chapter outlines.
        """
        outlines_text = "\n\n".join(current_outlines)
        prompt = f"""
        Enhance the following chapter outlines to make them more detailed, logically connected, and compelling. Ensure each chapter outline effectively contributes to the overall plot progression and thematic development, especially the dark and erotic elements of the novel.

        Current Chapter Outlines:
        ```
        {outlines_text}
        ```

        Refine and expand upon each chapter outline, focusing on:
        - Adding more specific details about events, character actions, and setting within each chapter.
        - Strengthening the transitions and connections between chapters to ensure a smooth narrative flow.
        - Ensuring each chapter outline clearly contributes to the overall three-act plot structure.
        - Deepening the integration of dark and erotic themes within the chapter events.
        - Checking for consistency and pacing across all chapter outlines.
        - Making sure each chapter outline creates sufficient intrigue and motivation to read the full chapter.

        Output should be a set of enhanced chapter outlines in text format, clearly numbered and formatted as individual chapter outlines.
        """
        logger.debug(f"Generated enhance chapter outlines prompt: {prompt}")
        return prompt

    def create_scene_outlines_prompt(self, chapter_outline: str, num_scenes_per_chapter: int) -> str:
        """
        Generates a prompt to create scene outlines for a given chapter outline.

        Breaks down a chapter outline into a specified number of scenes, providing
        a brief outline for each scene that details the events, setting, and characters
        involved, while continuing to emphasize the dark and erotic themes.

        Args:
            chapter_outline (str): The outline for the chapter.
            num_scenes_per_chapter (int): The desired number of scenes within the chapter.

        Returns:
            str: The generated prompt for scene outline creation.
        """
        prompt = f"""
        Based on the following chapter outline, create detailed outlines for {num_scenes_per_chapter} scenes within this chapter. Ensure the scenes logically break down the chapter's events and contribute to the overall narrative.

        Chapter Outline:
        ```
        {chapter_outline}
        ```

        For each scene, provide a concise outline (1-2 paragraphs) summarizing the key events, setting, characters present, and purpose of the scene within the chapter and overall story. The scene outlines should:
        - Logically break down the events described in the chapter outline.
        - Detail the setting and characters involved in each scene.
        - Clearly indicate the purpose of each scene in advancing the plot, developing characters, or enhancing themes (especially dark and erotic themes).
        - Be numbered sequentially within the chapter (Scene 1, Scene 2, etc.).

        Ensure the scene outlines collectively cover all key events of the chapter and provide a detailed guide for writing the scenes.
        """
        logger.debug(f"Generated scene outlines prompt: {prompt}")
        return prompt

    def create_enhance_scene_outlines_prompt(self, current_outlines: list[str]) -> str:
        """
        Generates a prompt to enhance existing scene outlines for a chapter.

        Refines and expands upon the existing scene outlines, ensuring they are detailed,
        logically sequenced, and effectively contribute to the chapter's and novel's
        plot and themes, with a continued focus on dark and erotic elements.

        Args:
            current_outlines (list[str]): A list of current scene outline texts for a chapter.

        Returns:
            str: The generated prompt for enhancing scene outlines.
        """
        outlines_text = "\n\n".join(current_outlines)
        prompt = f"""
        Enhance the following scene outlines for a chapter to make them more detailed, logically sequenced, and compelling. Ensure each scene outline effectively contributes to the chapter's narrative and the overall dark and erotic themes of the novel.

        Current Scene Outlines:
        ```
        {outlines_text}
        ```

        Refine and expand upon each scene outline, focusing on:
        - Adding more specific details about actions, dialogue, setting descriptions, and character emotions within each scene.
        - Strengthening the transitions and connections between scenes to ensure a smooth flow within the chapter.
        - Ensuring each scene outline clearly contributes to the chapter's objectives and the overall plot.
        - Deepening the integration of dark and erotic themes within the scene events and character interactions.
        - Checking for pacing and dramatic tension within and across the scene outlines.
        - Ensuring each scene outline provides a strong foundation for writing the full scene.

        Output should be a set of enhanced scene outlines in text format, clearly numbered and formatted as individual scene outlines.
        """
        logger.debug(f"Generated enhance scene outlines prompt: {prompt}")
        return prompt

    def create_scene_part_prompt(
        self, scene_outline: str, part_number: int, book_spec: BookSpec, chapter_outline: str, scene_outline_full: str
    ) -> str:
        """
        Generates a prompt to create a specific part of a scene's text content.

        This prompt is used to generate the actual narrative text for a scene, broken down into parts.
        It provides context from the book specification, chapter outline, and scene outline to ensure
        consistency and thematic relevance, particularly regarding dark and erotic elements.

        Args:
            scene_outline (str): The outline for the specific scene part.
            part_number (int): The part number of the scene (e.g., 1, 2, 3 for beginning, middle, end).
            book_spec (BookSpec): The BookSpec object for overall context.
            chapter_outline (str): The outline for the chapter containing the scene.
            scene_outline_full (str): The complete outline for the scene.

        Returns:
            str: The generated prompt for creating a part of the scene's text content.
        """
        book_spec_text = book_spec.json(indent=4)
        prompt = f"""
        Generate part {part_number} of the text for the following scene, based on the provided book specification, chapter outline, and scene outline.

        Book Specification:
        ```json
        {book_spec_text}
        ```

        Chapter Outline:
        ```
        {chapter_outline}
        ```

        Scene Outline:
        ```
        {scene_outline_full}
        ```

        Specifically for Part {part_number} of the scene, focusing on the following outline points:
        ```
        {scene_outline}
        ```

        Write this part of the scene in a compelling and descriptive manner, consistent with the tone, themes, and characters established in the book specification. Emphasize the dark and erotic elements as appropriate for this scene and the overall novel. Focus on vivid descriptions, engaging dialogue, and actions that move the scene forward.

        The generated text should be suitable for inclusion in a novel and should seamlessly connect with the preceding and subsequent parts of the scene (if applicable).
        """
        logger.debug(f"Generated scene part prompt (part {part_number}): {prompt}")
        return prompt

    def create_enhance_scene_part_prompt(
        self, scene_part: str, part_number: int, book_spec: BookSpec, chapter_outline: str, scene_outline_full: str
    ) -> str:
        """
        Generates a prompt to enhance an existing part of a scene's text content.

        Refines and improves an existing scene part, using the book specification, chapter outline,
        and scene outline for context. Focuses on enhancing the writing quality, deepening
        thematic elements, and ensuring consistency and impact, particularly regarding dark and erotic themes.

        Args:
            scene_part (str): The existing text content of the scene part.
            part_number (int): The part number of the scene.
            book_spec (BookSpec): The BookSpec object for overall context.
            chapter_outline (str): The outline for the chapter containing the scene.
            scene_outline_full (str): The complete outline for the scene.

        Returns:
            str: The generated prompt for enhancing a scene part.
        """
        book_spec_text = book_spec.json(indent=4)
        prompt = f"""
        Enhance the following part {part_number} of a scene to improve its writing quality, narrative impact, and thematic depth, while maintaining consistency with the book specification, chapter outline, and scene outline.

        Book Specification:
        ```json
        {book_spec_text}
        ```

        Chapter Outline:
        ```
        {chapter_outline}
        ```

        Scene Outline:
        ```
        {scene_outline_full}
        ```

        Current Scene Part {part_number} Text:
        ```
        {scene_part}
        ```

        Refine and enhance this scene part, focusing on:
        - Improving sentence structure, vocabulary, and descriptive language.
        - Deepening character emotions and motivations within the scene.
        - Strengthening the pacing and dramatic tension of the scene part.
        - Enhancing the integration of dark and erotic themes within the text.
        - Ensuring the scene part effectively fulfills its purpose within the scene and chapter.
        - Checking for consistency with the overall tone and style of the novel.
        - Making the scene part more engaging and immersive for the reader.

        Output should be the enhanced text for scene part {part_number}.
        """
        logger.debug(f"Generated enhance scene part prompt (part {part_number}): {prompt}")
        return prompt

    def optimize_prompt_tokens(self, prompt: str) -> str:
        """
        [Placeholder] Optimizes prompt tokens to reduce prompt length (future implementation).

        This method is intended to implement techniques for reducing the token count of prompts
        to improve efficiency and potentially reduce LLM processing costs. Currently, it is a placeholder.

        Args:
            prompt (str): The prompt text to be optimized.

        Returns:
            str: The optimized prompt text (currently returns the original prompt).
        """
        # Placeholder for token optimization logic (e.g., summarization, keyword extraction)
        logger.debug("Prompt token optimization placeholder - returning original prompt.")
        return prompt

    def batch_prompts(self, prompts: list[str]) -> list[str]:
        """
        [Placeholder] Batches prompts for more efficient LLM processing (future implementation).

        This method is intended to implement prompt batching techniques to send multiple prompts
        to the LLM in a single request, if supported by the Ollama API or through custom batching logic.
        Currently, it is a placeholder.

        Args:
            prompts (list[str]): A list of prompt texts to be batched.

        Returns:
            list[str]: A list of batched prompts (currently returns the original list).
        """
        # Placeholder for prompt batching logic
        logger.debug("Prompt batching placeholder - returning original prompts.")
        return prompts
```````