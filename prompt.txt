Project Path: /home/tlh/refactored_gui_fict_fab

Source Tree:

```
refactored_gui_fict_fab
├── app.py
├── prompt.txt
├── run
├── utils
│   ├── __pycache__
│   ├── config.py
│   ├── file_handler.py
│   ├── logger.py
│   ├── data_validation.py
│   └── async_utils.py
├── requirements.txt
├── flake.lock
├── setup-env.sh
├── streamlit_app
│   ├── __pycache__
│   ├── components
│   │   ├── __pycache__
│   │   ├── book_spec_view.py
│   │   ├── scene_part_view.py
│   │   ├── plot_outline_view.py
│   │   ├── scene_outline_view.py
│   │   ├── book_text_view.py
│   │   ├── __init__.py
│   │   └── chapter_outline_view.py
│   └── __init__.py
├── core
│   ├── __pycache__
│   ├── content_generation
│   │   ├── __pycache__
│   │   ├── plot_outline_generator.py
│   │   ├── scene_outline_generator.py
│   │   ├── chapter_outline_generator.py
│   │   ├── book_assembler.py
│   │   ├── book_spec_generator.py
│   │   ├── base_generator.py
│   │   ├── scene_part_generator.py
│   │   └── __init__.py
│   ├── book_spec.py
│   ├── plot_outline.py
│   └── project_manager.py
├── flake.nix
└── llm
    ├── __pycache__
    ├── prompt_manager
    │   ├── __pycache__
    │   ├── book_spec_prompts.py
    │   ├── scene_part_prompts.py
    │   ├── base_prompts.py
    │   ├── plot_outline_prompts.py
    │   ├── chapter_outline_prompts.py
    │   ├── prompt_manager.py
    │   ├── scene_outline_prompts.py
    │   └── __init__.py
    ├── llm_client.py
    └── __init__.py

```

`/home/tlh/refactored_gui_fict_fab/app.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/app.py
import streamlit as st
import asyncio
import os
import sys

llm_parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "llm"))
if llm_parent_dir not in sys.path:
    sys.path.insert(0, llm_parent_dir)

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from streamlit_app.components.book_spec_view import book_spec_display
from streamlit_app.components.plot_outline_view import plot_outline_display
from streamlit_app.components.chapter_outline_view import chapter_outlines_display
from streamlit_app.components.scene_outline_view import scene_outlines_display
from streamlit_app.components.scene_part_view import scene_part_display
from streamlit_app.components.book_text_view import book_text_display

from core.content_generation.book_spec_generator import BookSpecGenerator
from core.content_generation.plot_outline_generator import PlotOutlineGenerator
from core.content_generation.chapter_outline_generator import ChapterOutlineGenerator
from core.content_generation.scene_outline_generator import SceneOutlineGenerator
from core.content_generation.scene_part_generator import ScenePartGenerator
from core.content_generation.book_assembler import BookAssembler
from core.project_manager import ProjectManager
from llm.prompt_manager.prompt_manager import DynamicPromptManager
from llm.llm_client import OpenAILLMClient
from utils.config import config
from core.book_spec import BookSpec
from core.plot_outline import PlotOutline, ChapterOutline, SceneOutline
from utils.logger import logger


def main():
    st.set_page_config(
        page_title="Fiction Fabricator",
        page_icon="🕉️",
        layout="wide",
        initial_sidebar_state="expanded",
    )
    st.title("Fiction Fabricator")

    if "openai_client" not in st.session_state:
        st.session_state.openai_client = OpenAILLMClient()
    if "prompt_manager" not in st.session_state:
        st.session_state.prompt_manager = DynamicPromptManager()
    if "book_spec_generator" not in st.session_state:
        st.session_state.book_spec_generator = BookSpecGenerator(
            st.session_state.prompt_manager, config.get_ollama_model_name()
        )
    if "plot_outline_generator" not in st.session_state:
        st.session_state.plot_outline_generator = PlotOutlineGenerator(
            st.session_state.prompt_manager, config.get_ollama_model_name()
        )
    if "chapter_outline_generator" not in st.session_state:
        st.session_state.chapter_outline_generator = ChapterOutlineGenerator(
            st.session_state.prompt_manager, config.get_ollama_model_name()
        )
    if "scene_outline_generator" not in st.session_state:
        st.session_state.scene_outline_generator = SceneOutlineGenerator(
            st.session_state.prompt_manager, config.get_ollama_model_name()
        )
    if "scene_part_generator" not in st.session_state:
        st.session_state.scene_part_generator = ScenePartGenerator(
            st.session_state.prompt_manager, config.get_ollama_model_name()
        )
    if "book_assembler" not in st.session_state:
        st.session_state.book_assembler = BookAssembler()
    if "project_manager" not in st.session_state:
        st.session_state.project_manager = ProjectManager()
    if "available_models" not in st.session_state:
        st.session_state.available_models = (
            asyncio.run(st.session_state.openai_client.list_models()) or []
        )
    if "selected_model" not in st.session_state:
        st.session_state.selected_model = config.get_ollama_model_name()
    st.session_state.story_idea = st.session_state.get("story_idea", "")
    st.session_state.book_spec = st.session_state.get("book_spec", None)
    st.session_state.plot_outline = st.session_state.get("plot_outline", None)
    st.session_state.chapter_outlines = st.session_state.get("chapter_outlines", [])
    st.session_state.scene_outlines = st.session_state.get("scene_outlines", {})
    st.session_state.scene_parts = st.session_state.get("scene_parts", {})
    st.session_state.project_name = st.session_state.get("project_name", "")
    st.session_state.num_chapters = st.session_state.get("num_chapters", 10)
    st.session_state.max_scenes_per_chapter = st.session_state.get(
        "max_scenes_per_chapter", 3
    )
    st.session_state.scene_parts_text = st.session_state.get("scene_parts_text", {})
    st.session_state.book_text = st.session_state.get("book_text", None)
    st.session_state.project_error = st.session_state.get("project_error", None)

    with st.sidebar:
        st.header("Settings & Project")

        model_options = st.session_state.available_models or [
            config.get_ollama_model_name()
        ]
        model_selectbox = st.selectbox(
            "Select Model (REQUIRED)",
            model_options,
            index=(
                model_options.index(st.session_state.selected_model)
                if st.session_state.selected_model in model_options
                else 0
            ),
            key="model_selectbox",
        )
        if model_selectbox != st.session_state.selected_model:
            st.session_state.selected_model = model_selectbox
            for generator_key in [
                "book_spec_generator",
                "plot_outline_generator",
                "chapter_outline_generator",
                "scene_outline_generator",
                "scene_part_generator",
            ]:
                if generator_key in st.session_state:
                    st.session_state[generator_key].model_name = (
                        st.session_state.selected_model
                    )
            st.rerun()
        st.write(f"**Selected Model:** `{st.session_state.selected_model}`")

        if st.session_state.selected_model:
            st.sidebar.subheader("Project Management")
            project_dir = config.get_project_directory()
            logger.debug(f"Project directory for listing files: {project_dir}")
            try:
                all_files_and_dirs = os.listdir(project_dir)
                logger.debug(
                    f"Items in project directory: {all_files_and_dirs}"
                )  # Log ALL items

                project_files = []
                for item_name in all_files_and_dirs:  # Iterate through item names
                    item_path = os.path.join(
                        project_dir, item_name
                    )  # Construct full item path
                    logger.debug(
                        f"Checking item: {item_name}, path: {item_path}"
                    )  # Log each item being checked

                    if os.path.isdir(item_path):  # Check if it's a directory
                        logger.debug(f"  - Is a directory")
                        project_json_filepath = os.path.join(
                            item_path, f"{item_name}.json"
                        )  # Construct project.json path
                        logger.debug(
                            f"  - Checking for project JSON file: {project_json_filepath}"
                        )  # Log json path

                        if os.path.isfile(
                            project_json_filepath
                        ):  # Check if project.json exists
                            logger.info(
                                f"  - Found project JSON file: {project_json_filepath}"
                            )  # Info log if found
                            project_files.append(
                                item_name
                            )  # Add project directory name
                        else:
                            logger.debug(
                                f"  - Project JSON file NOT found"
                            )  # Debug log if json not found
                    else:
                        logger.debug(
                            f"  - Not a directory (ignoring)"
                        )  # Debug log if not a directory

                logger.debug(
                    f"Filtered project files (subdirectories with project.json): {project_files}"
                )  # Log final list

            except FileNotFoundError:
                logger.warning(f"Project directory not found: {project_dir}")
                project_files = []
            except Exception as e:
                logger.error(f"Error listing project directory: {e}")
                project_files = []

            st.write(f"Project Files (from listdir): {project_files}")
            project_options = ["New Project"] + project_files
            selected_project = st.selectbox(
                "Select Project", project_options, key="project_selectbox"
            )

            if selected_project == "New Project":
                project_name = st.text_input(
                    "New Project Name", value="", key="new_project_name_input"
                )
            else:
                project_name = selected_project

            st.session_state.project_name = st.text_input(
                "Project Name", value=project_name
            )

            col1, col2 = st.columns(2)
            with col1:
                if st.button("Save Project", key="save_project_button"):
                    if st.session_state.project_name:
                        try:
                            st.session_state.project_manager.save_project(
                                st.session_state.project_name,
                                st.session_state.story_idea,
                                st.session_state.book_spec,
                                st.session_state.plot_outline,
                                st.session_state.chapter_outlines,
                                st.session_state.scene_outlines,
                                st.session_state.scene_parts,
                                st.session_state.scene_parts_text,
                                st.session_state.book_text,
                            )
                            st.success(
                                f"Project '{st.session_state.project_name}' saved!"
                            )
                            st.session_state.project_name = project_name
                            st.session_state.project_error = None
                        except (IOError, TypeError, ValueError) as e:
                            st.session_state.project_error = (
                                f"Error saving project: {e}"
                            )
                    else:
                        st.warning("Please enter a project name to save.")
            with col2:
                if st.button("Load Project", key="load_project_button"):
                    if (
                        st.session_state.project_name
                        and st.session_state.project_name != "New Project"
                    ):
                        try:
                            st.session_state.book_spec = None

                            loaded_data = st.session_state.project_manager.load_project(
                                st.session_state.project_name
                            )
                            if loaded_data:
                                st.session_state.project_name = project_name
                                st.session_state.story_idea = loaded_data.get(
                                    "story_idea", ""
                                )
                                st.session_state.book_spec = (
                                    BookSpec(**loaded_data["book_spec"])
                                    if loaded_data.get("book_spec")
                                    else None
                                )
                                st.session_state.plot_outline = (
                                    PlotOutline(**loaded_data["plot_outline"])
                                    if loaded_data.get("plot_outline")
                                    else None
                                )
                                st.session_state.chapter_outlines = [
                                    ChapterOutline(**co)
                                    for co in (
                                        loaded_data.get("chapter_outlines") or []
                                    )
                                ]
                                scene_outlines_data = loaded_data.get(
                                    "scene_outlines", {}
                                )
                                st.session_state.scene_outlines = {
                                    int(chapter_num): [
                                        SceneOutline(**so) for so in scene_outlines
                                    ]
                                    for chapter_num, scene_outlines in (
                                        scene_outlines_data or {}
                                    ).items()
                                }
                                st.session_state.scene_parts = loaded_data.get(
                                    "scene_parts", {}
                                )
                                st.session_state.scene_parts_text = loaded_data.get(
                                    "scene_parts_text", {}
                                )
                                st.session_state.book_text = loaded_data.get(
                                    "book_text", None
                                )
                                st.success(
                                    f"Project '{st.session_state.project_name}' loaded!"
                                )
                                st.session_state.project_error = None
                            else:
                                st.warning(
                                    f"No project data loaded (empty data) for '{st.session_state.project_name}'."
                                )
                                st.session_state.project_error = f"No project data loaded for '{st.session_state.project_name}' - empty data."
                        except FileNotFoundError as e:
                            st.error(
                                f"Project file '{st.session_state.project_name}.json' not found: {e}"
                            )
                            st.session_state.project_error = f"Project file '{st.session_state.project_name}.json' not found: {e}"
                        except json.JSONDecodeError as e:
                            st.error(f"Error decoding project JSON: {e}")
                            st.session_state.project_error = (
                                f"Error decoding project JSON: {e}"
                            )
                        except Exception as e:
                            st.error(f"General error loading project: {e}")
                            st.session_state.project_error = (
                                f"General error loading project: {e}"
                            )

    if st.session_state.selected_model:
        col_workflow, col_display = st.columns([1, 1], gap="large")

        with col_workflow:
            st.header("Novel Generation Workflow")

            if st.session_state.project_error:
                st.error(st.session_state.project_error)

            with st.container():
                st.subheader("1. Story Idea")
                st.session_state.story_idea = st.text_area(
                    "Enter your story idea:",
                    value=st.session_state.story_idea,
                    height=100,
                    key="story_idea_textarea",
                    on_change=None,
                )

                if st.session_state.story_idea and not st.session_state.book_spec:
                    with st.spinner("Generating Book Specification..."):
                        generated_spec = asyncio.run(
                            st.session_state.book_spec_generator.generate(
                                st.session_state.story_idea,
                                st.session_state.project_name,
                            )
                        )
                    if generated_spec:
                        st.session_state.book_spec = generated_spec
                        st.session_state.project_manager.save_project(
                            st.session_state.project_name,
                            st.session_state.story_idea,
                            st.session_state.book_spec,
                            st.session_state.plot_outline,
                            st.session_state.chapter_outlines,
                            st.session_state.scene_outlines,
                            st.session_state.scene_parts,
                            st.session_state.scene_parts_text,
                            st.session_state.book_text,
                        )
                        st.success(
                            "Book Specification Generated and Project Autosaved!"
                        )
                        st.rerun()
                    else:
                        st.error("Failed to generate Book Specification.")

            with st.container():
                book_spec_display(
                    st.session_state.book_spec, st.session_state.book_spec_generator
                )

            if st.session_state.book_spec:
                with st.container():
                    plot_outline_display(
                        st.session_state.plot_outline,
                        st.session_state.plot_outline_generator,
                    )

            if st.session_state.plot_outline:
                with st.container():
                    chapter_outlines_display(
                        st.session_state.chapter_outlines,
                        st.session_state.chapter_outline_generator,
                    )

            if st.session_state.chapter_outlines:
                with st.container():
                    scene_outlines_display(
                        st.session_state.scene_outlines,
                        st.session_state.scene_outline_generator,
                    )

            if st.session_state.scene_outlines:
                with st.container():
                    scene_part_display(
                        st.session_state.scene_parts_text,
                        st.session_state.scene_part_generator,
                        st.session_state.book_spec,
                        st.session_state.chapter_outlines,
                        st.session_state.scene_outlines,
                    )

            if st.session_state.scene_parts_text:
                with st.container():
                    st.subheader("7. Assemble Book Text")
                    if st.button(
                        "Assemble Book Text",
                        disabled=not st.session_state.scene_parts_text,
                        key="assemble_book_button",
                    ):
                        with st.spinner("Assembling Book Text..."):
                            st.session_state.book_text = (
                                st.session_state.book_assembler.assemble_book_text(
                                    st.session_state.scene_parts_text
                                )
                            )
                        if st.session_state.book_text:
                            st.success("Book text assembled!")
                            st.download_button(
                                label="Download Book Text",
                                data=st.session_state.book_text,
                                file_name="book_text.txt",
                                mime="text/plain",
                            )
                        else:
                            st.error("Failed to assemble book text.")

        with col_display:
            st.header("Project Data Display")
            if st.session_state.project_error:
                st.error(st.session_state.project_error)

            st.subheader("Story Idea")
            st.write(st.session_state.story_idea)

            if st.session_state.book_spec:
                book_spec_display(
                    st.session_state.book_spec, st.session_state.book_spec_generator
                )
            if st.session_state.plot_outline:
                plot_outline_display(
                    st.session_state.plot_outline,
                    st.session_state.plot_outline_generator,
                )
            if st.session_state.chapter_outlines:
                chapter_outlines_display(
                    st.session_state.chapter_outlines,
                    st.session_state.chapter_outline_generator,
                )
            if st.session_state.scene_outlines:
                scene_outlines_display(
                    st.session_state.scene_outlines,
                    st.session_state.scene_outline_generator,
                )
            if st.session_state.scene_parts_text:
                scene_part_display(
                    st.session_state.scene_parts_text,
                    st.session_state.scene_part_generator,
                    st.session_state.book_spec,
                    st.session_state.chapter_outlines,
                    st.session_state.scene_outlines,
                )
            if st.session_state.book_text:
                book_text_display(st.session_state.book_text)
    else:
        st.warning("Please select an Ollama model in the sidebar to begin.")


if __name__ == "__main__":
    main()

```````

`/home/tlh/refactored_gui_fict_fab/run`:

```````
#!/usr/bin/env bash
source .venv/bin/activate
.venv/bin/streamlit run app.py
```````

`/home/tlh/refactored_gui_fict_fab/utils/config.py`:

```````py
# utils/config.py
import os

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import field_validator
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file


class Config(BaseSettings):
    """
    Configuration manager for the Fiction Fabricator application.
    """

    project_directory: str = "data"
    log_level: str = "INFO"
    ollama_model_name: str = "mistral"  # Default to Mistral as a common Ollama model
    ollama_base_url: str = (
        "http://localhost:11434"  # This is only used by the old client
    )
    openai_base_url: str = "http://localhost:11434/v1"

    @field_validator("log_level")
    @classmethod
    def log_level_must_be_valid(cls, v: str) -> str:
        allowed_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if v.upper() not in allowed_levels:
            raise ValueError(
                f"Invalid log level: {v}.  Must be one of: {allowed_levels}"
            )
        return v.upper()

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8")

    def get_project_directory(self) -> str:
        return self.project_directory

    def get_log_level(self) -> str:
        return self.log_level

    def get_ollama_model_name(self) -> str:
        return self.ollama_model_name
    
    def get_openai_base_url(self) -> str:
        return self.openai_base_url

    def get_ollama_base_url(self) -> str:
        return self.ollama_base_url

    def set_ollama_model_name(self, model_name: str) -> None:
        self.ollama_model_name = model_name


config = Config()
```````

`/home/tlh/refactored_gui_fict_fab/utils/file_handler.py`:

```````py
# utils/file_handler.py
import json
import os

from utils.logger import logger


def save_json(data: dict, filepath: str) -> None:
    """
    Saves data to a JSON file.
    """
    try:
        os.makedirs(os.path.dirname(filepath), exist_ok=True)  # Ensure directory exists
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4)  # Save JSON with indentation for readability
        logger.info("JSON data saved to: %s", filepath)  # Lazy format
    except Exception as e:
        logger.error("Error saving JSON to %s: %s", filepath, e)  # Lazy format
        raise  # Re-raise the exception for handling higher up if needed


def load_json(filepath: str) -> dict:
    """
    Loads data from a JSON file.
    """
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            data = json.load(f)
        logger.info("JSON data loaded from: %s", filepath)  # Lazy format
        return data
    except FileNotFoundError:
        logger.error("JSON file not found: %s", filepath)  # Lazy format
        raise
    except json.JSONDecodeError as e:
        logger.error("Error decoding JSON from %s: %s", filepath, e)  # Lazy format
        raise
    except Exception as e:
        logger.error("Error loading JSON from %s: %s", filepath, e)  # Lazy format
        raise


def save_markdown(text: str, filepath: str) -> None:
    """
    Saves text content to a Markdown file.
    """
    try:
        os.makedirs(os.path.dirname(filepath), exist_ok=True)  # Ensure directory exists
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(text)
        logger.info("Markdown content saved to: %s", filepath)  # Lazy format
    except Exception as e:
        logger.error("Error saving Markdown to %s: %s", filepath, e)  # Lazy format
        raise  # Re-raise the exception
```````

`/home/tlh/refactored_gui_fict_fab/utils/logger.py`:

```````py
# utils/logger.py
import logging
import sys

from utils.config import config  # Import the config object


def setup_logger() -> logging.Logger:
    """
    Sets up and configures a logger for the Fiction Fabricator application.
    """
    app_logger = logging.getLogger(__name__)
    log_level_str = config.get_log_level()  # Access the log level

    log_levels = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
    }

    log_level = log_levels.get(log_level_str, logging.INFO)
    app_logger.setLevel(log_level)

    # Create console handler
    console_handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter(
        "%(asctime)s - %(levelname)s - %(module)s - %(message)s"
    )
    console_handler.setFormatter(formatter)
    app_logger.addHandler(console_handler)

    return app_logger


logger = setup_logger()
```````

`/home/tlh/refactored_gui_fict_fab/utils/data_validation.py`:

```````py
# utils/data_validation.py
"""
Utility functions for data validation.

This module is designed to house custom data validation functions
that go beyond the basic validation provided by Pydantic. It's 
intended to encapsulate more complex or application-specific 
validation logic, ensuring data integrity and consistency 
within the Fiction Fabricator application.
"""

from typing import List, Dict, Any
from utils.logger import logger


def validate_scene_outline_consistency(
    chapter_outlines: List[Dict[str, Any]],
    scene_outlines: Dict[int, List[Dict[str, Any]]],
) -> bool:
    """
    Validates consistency between chapter outlines and scene outlines.

    Checks:
    1.  That every chapter number referenced in `scene_outlines` has a
        corresponding entry in `chapter_outlines`.
    2.  That scene numbers within each chapter are sequential and start from 1.
    """
    consistent = True
    chapter_numbers = {co["chapter_number"] for co in chapter_outlines}

    for chapter_num, scenes in scene_outlines.items():
        if chapter_num not in chapter_numbers:
            logger.warning(
                "Scene outlines exist for chapter %s, but no corresponding chapter outline found.",
                chapter_num,
            )
            consistent = False

        expected_scene_num = 1
        for scene in scenes:
            if scene["scene_number"] != expected_scene_num:
                logger.warning(
                    "Scene number mismatch in chapter %s. Expected %s, got %s.",
                    chapter_num,
                    expected_scene_num,
                    scene["scene_number"],
                )
                consistent = False
            expected_scene_num += 1
    return consistent


def validate_scene_part_text_structure(
    scene_parts_text: Dict[int, Dict[int, Dict[int, str]]]
) -> bool:
    """
    Validates structure of the scene_parts_text
    """
    consistent = True

    if not isinstance(scene_parts_text, dict):
        logger.error("Scene_parts_text is not a dictionary")
        return False

    for chapter_num, chapter_data in scene_parts_text.items():
        if not isinstance(chapter_num, int):
            logger.warning(
                "scene_parts_text chapter number is not an int: %s", type(chapter_num)
            )
            consistent = False

        if not isinstance(chapter_data, dict):
            logger.warning(
                "scene_parts_text chapter data is not a dict: %s", type(chapter_data)
            )
            consistent = False
            continue

        for scene_num, scene_data in chapter_data.items():
            if not isinstance(scene_num, int):
                logger.warning(
                    "scene_parts_text scene number is not an int: %s", type(scene_num)
                )
                consistent = False

            if not isinstance(scene_data, dict):
                logger.warning(
                    "scene_parts_text scene data is not a dict: %s", type(scene_data)
                )
                consistent = False
                continue

            for part_num, part_text in scene_data.items():
                if not isinstance(part_num, int):
                    logger.warning(
                        "scene_parts_text part number is not an int: %s", type(part_num)
                    )
                    consistent = False

                if not isinstance(part_text, str):
                    logger.warning(
                        "scene_parts_text part data is not a string: %s",
                        type(part_text),
                    )
                    consistent = False

    return consistent

```````

`/home/tlh/refactored_gui_fict_fab/utils/async_utils.py`:

```````py
# utils/async_utils.py
import asyncio
from typing import Coroutine, Any, Optional


async def timeout_wrapper(
    coro: Coroutine, timeout: Optional[float] = None, default_timeout: float = 60.0
) -> Any:
    """
    Wraps an async coroutine with a timeout.
    """
    try:
        if timeout is None:
            timeout = default_timeout
        return await asyncio.wait_for(coro, timeout=timeout)
    except asyncio.TimeoutError:
        raise  # Re-raise the TimeoutError to be handled by the caller

```````

`/home/tlh/refactored_gui_fict_fab/requirements.txt`:

```````txt
# requirements.txt
streamlit
openai
pydantic
python-dotenv
black
pytest
pydantic-settings
aiohttp
requests
numpy
```````

`/home/tlh/refactored_gui_fict_fab/flake.lock`:

```````lock
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1740828860,
        "narHash": "sha256-cjbHI+zUzK5CPsQZqMhE3npTyYFt9tJ3+ohcfaOF/WM=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "303bd8071377433a2d8f76e684ec773d70c5b642",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}

```````

`/home/tlh/refactored_gui_fict_fab/setup-env.sh`:

```````sh
#!/usr/bin/env bash

# Create virtual environment
if ! python -m venv .venv; then
  echo "Error: Failed to create virtual environment."
  exit 1
fi

# Activate virtual environment
source .venv/bin/activate

# Install dependencies
if ! pip install -r requirements.txt; then
  echo "Error: Failed to install dependencies. Make sure 'requirements.txt' exists."
  exit 1
fi

echo "Virtual environment created and dependencies installed successfully."
echo "Activate the virtual environment in your current shell using: source .venv/bin/activate"
echo "Then run the application using the './run' script."

    
```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/book_spec_view.py`:

```````py
# streamlit_app/components/book_spec_view.py
import streamlit as st
import asyncio
from core.book_spec import BookSpec
from typing import Optional
from core.content_generation.book_spec_generator import BookSpecGenerator
from utils.logger import logger


def book_spec_display(
    book_spec: Optional[BookSpec], book_spec_generator: BookSpecGenerator
):
    """
    Displays the BookSpec data, provides editing capabilities, and automatically generates the book spec upon entering a story idea.
    """
    st.subheader("Book Specification")

    story_idea_input = st.session_state.story_idea  # Get story idea from session state

    if book_spec:  # If book_spec exists, display the editable fields
        st.write("### Edit Book Specification")

        # Initialize individual component states if they don't exist
        if "book_spec_title" not in st.session_state:
            st.session_state.book_spec_title = book_spec.title
        if "book_spec_genre" not in st.session_state:
            st.session_state.book_spec_genre = book_spec.genre
        if "book_spec_setting" not in st.session_state:
            st.session_state.book_spec_setting = book_spec.setting
        if "book_spec_themes" not in st.session_state:
            st.session_state.book_spec_themes = ", ".join(book_spec.themes)
        if "book_spec_tone" not in st.session_state:
            st.session_state.book_spec_tone = book_spec.tone
        if "book_spec_point_of_view" not in st.session_state:
            st.session_state.book_spec_point_of_view = book_spec.point_of_view
        if "book_spec_characters" not in st.session_state:
            st.session_state.book_spec_characters = "\n".join(book_spec.characters)
        if "book_spec_premise" not in st.session_state:
            st.session_state.book_spec_premise = book_spec.premise

        # Create input fields for each spec element
        st.session_state.book_spec_title = st.text_input(
            "Title", value=st.session_state.book_spec_title, key="title_input"
        )
        st.session_state.book_spec_genre = st.text_input(
            "Genre", value=st.session_state.book_spec_genre, key="genre_input"
        )
        st.session_state.book_spec_setting = st.text_area(
            "Setting",
            value=st.session_state.book_spec_setting,
            height=100,
            key="setting_input",
        )
        st.session_state.book_spec_themes = st.text_input(
            "Themes (comma-separated)",
            value=st.session_state.book_spec_themes,
            key="themes_input",
        )
        st.session_state.book_spec_tone = st.text_input(
            "Tone", value=st.session_state.book_spec_tone, key="tone_input"
        )
        st.session_state.book_spec_point_of_view = st.text_input(
            "Point of View",
            value=st.session_state.book_spec_point_of_view,
            key="point_of_view_input",
        )
        st.session_state.book_spec_characters = st.text_area(
            "Characters (one description per line)",
            value=st.session_state.book_spec_characters,
            height=150,
            key="characters_input",
        )
        st.session_state.book_spec_premise = st.text_area(
            "Premise",
            value=st.session_state.book_spec_premise,
            height=100,
            key="premise_input",
        )

        col_save, _ = st.columns([1, 3])  # Removed enhance column
        with col_save:
            if st.button("Save Book Spec (Manual Edit)", key="save_book_spec_button"):
                # Update book_spec with current input values
                st.session_state.book_spec = BookSpec(
                    title=st.session_state.book_spec_title,
                    genre=st.session_state.book_spec_genre,
                    setting=st.session_state.book_spec_setting,
                    themes=[
                        theme.strip()
                        for theme in st.session_state.book_spec_themes.split(",")
                    ],
                    tone=st.session_state.book_spec_tone,
                    point_of_view=st.session_state.book_spec_point_of_view,
                    characters=[
                        char.strip()
                        for char in st.session_state.book_spec_characters.splitlines()
                    ],
                    premise=st.session_state.book_spec_premise,
                )
                # Autosave project after manual edit save
                st.session_state.project_manager.save_project(
                    st.session_state.project_name,
                    st.session_state.story_idea,
                    st.session_state.book_spec,
                    st.session_state.plot_outline,
                    st.session_state.chapter_outlines,
                    st.session_state.scene_outlines,
                    st.session_state.scene_parts,
                    st.session_state.scene_parts_text,
                    st.session_state.book_text,
                )
                st.success(
                    "Book Specification Saved (Manual Edit) and Project Autosaved!"
                )

        st.json(
            st.session_state.book_spec.model_dump()
            if st.session_state.book_spec
            else {}
        )

```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/scene_part_view.py`:

```````py
# streamlit_app/components/scene_part_view.py
import streamlit as st
import asyncio
from typing import Optional, Dict, List
from core.content_generation.scene_part_generator import ScenePartGenerator
from core.plot_outline import ChapterOutline, SceneOutline
from core.book_spec import BookSpec


def scene_part_display(
    scene_parts_text: Dict[int, Dict[int, Dict[int, str]]], # Moved to first
    scene_part_generator: ScenePartGenerator,
    book_spec: Optional[BookSpec],
    chapter_outlines: Optional[List[ChapterOutline]],
    scene_outlines: Optional[Dict[int, List[SceneOutline]]],
):
    """
    Displays and manages scene parts text generation and enhancement
    with autosave functionality. Relies on st.session_state.scene_parts_text directly.
    """
    st.subheader("Scene Parts - Text Generation")

    if st.button(
        "Generate Scene Parts Text (All Scenes)",
        key="generate_scene_parts_button",
        disabled=st.session_state.scene_parts_text
        or not st.session_state.scene_outlines,
    ):
        if (
            st.session_state.scene_outlines
            and scene_part_generator
            and book_spec
            and chapter_outlines
        ):
            with st.spinner("Generating Scene Parts Text... This may take a while."):
                generated_scene_parts_text = {}
                for (
                    chapter_number,
                    scene_outlines_chapter,
                ) in st.session_state.scene_outlines.items():
                    generated_scene_parts_text[chapter_number] = {}
                    chapter_outline = next(
                        (
                            co
                            for co in chapter_outlines
                            if co.chapter_number == chapter_number
                        ),
                        ChapterOutline(
                            chapter_number=chapter_number,
                            summary="Placeholder Chapter Outline",
                        ),
                    )

                    for scene_outline in scene_outlines_chapter:
                        generated_scene_parts_text[chapter_number][
                            scene_outline.scene_number
                        ] = {}
                        num_parts = 3
                        for part_number in range(1, num_parts + 1):
                            generated_part = asyncio.run(
                                scene_part_generator.generate(
                                    scene_outline,
                                    part_number,
                                    book_spec,
                                    chapter_outline,
                                    scene_outline,
                                )
                            )
                            if generated_part:
                                generated_scene_parts_text[chapter_number][
                                    scene_outline.scene_number
                                ][part_number] = generated_part
                            else:
                                st.error(
                                    f"Failed to generate part {part_number} of Scene {scene_outline.scene_number}, Chapter {chapter_number}."
                                )
                st.session_state.scene_parts_text = generated_scene_parts_text
                st.session_state.project_manager.save_project(
                    st.session_state.project_name,
                    st.session_state.story_idea,
                    st.session_state.book_spec,
                    st.session_state.plot_outline,
                    st.session_state.chapter_outlines,
                    st.session_state.scene_outlines,
                    st.session_state.scene_parts,
                    st.session_state.scene_parts_text,
                    st.session_state.book_text,
                )
                st.success(
                    "Scene parts generated for all scenes and Project Autosaved!"
                )
                st.rerun()
        else:
            st.warning(
                "Scene Outlines, Book Specification, and Chapter Outlines are required to generate Scene Parts."
            )

    if st.session_state.scene_parts_text:
        with st.expander("Enhance Scene Parts", expanded=False):
            chapter_numbers = list(st.session_state.scene_parts_text.keys())
            if chapter_numbers:
                selected_chapter = st.selectbox(
                    "Select Chapter for Enhancement",
                    chapter_numbers,
                    key="chapter_selectbox_enhance_part",
                )
                scene_numbers = list(
                    st.session_state.scene_parts_text.get(selected_chapter, {}).keys()
                )

                if scene_numbers:
                    selected_scene = st.selectbox(
                        "Select Scene for Enhancement",
                        scene_numbers,
                        key="scene_selectbox_enhance_part",
                    )
                    part_numbers = list(
                        st.session_state.scene_parts_text.get(selected_chapter, {})
                        .get(selected_scene, {})
                        .keys()
                    )

                    if part_numbers:
                        selected_part = st.selectbox(
                            "Select Part for Enhancement",
                            part_numbers,
                            key="part_selectbox_enhance_part",
                        )

                        if st.button(
                            f"Enhance Part {selected_part} of Scene {selected_scene}, Chapter {selected_chapter}",
                            key="enhance_single_scene_part_button",
                        ):
                            if (
                                scene_part_generator
                                and book_spec
                                and chapter_outlines
                                and scene_outlines
                            ):
                                with st.spinner(
                                    f"Enhancing Part {selected_part} of Scene {selected_scene}, Chapter {selected_chapter}..."
                                ):
                                    current_part_text = (
                                        st.session_state.scene_parts_text[
                                            selected_chapter
                                        ][selected_scene][selected_part]
                                    )

                                    chapter_outline = next(
                                        (
                                            co
                                            for co in chapter_outlines
                                            if co.chapter_number == selected_chapter
                                        ),
                                        ChapterOutline(
                                            chapter_number=selected_chapter,
                                            summary="Placeholder Chapter Outline",
                                        ),
                                    )

                                    scene_outline_full = next(
                                        (
                                            so
                                            for so in scene_outlines.get(
                                                selected_chapter, []
                                            )
                                            if so.scene_number == selected_scene
                                        ),
                                        SceneOutline(
                                            scene_number=selected_scene,
                                            summary="Placeholder Scene Outline",
                                        ),
                                    )

                                    enhanced_part = asyncio.run(
                                        scene_part_generator.enhance(
                                            current_part_text,
                                            selected_part,
                                            book_spec,
                                            chapter_outline,
                                            scene_outline_full,
                                        )
                                    )

                                    if enhanced_part:
                                        st.session_state.scene_parts_text[
                                            selected_chapter
                                        ][selected_scene][selected_part] = enhanced_part
                                        st.session_state.project_manager.save_project(
                                            st.session_state.project_name,
                                            st.session_state.story_idea,
                                            st.session_state.book_spec,
                                            st.session_state.plot_outline,
                                            st.session_state.chapter_outlines,
                                            st.session_state.scene_outlines,
                                            st.session_state.scene_parts,
                                            st.session_state.scene_parts_text,
                                            st.session_state.book_text,
                                        )
                                        st.success(
                                            f"Part {selected_part} of Scene {selected_scene}, Chapter {selected_chapter} enhanced and Project Autosaved!"
                                        )
                                        st.rerun()
                                    else:
                                        st.error(
                                            f"Failed to enhance Part {selected_part} of Scene {selected_scene}, Chapter {selected_chapter}."
                                        )
                            else:
                                st.error(
                                    "Generator or context data not properly initialized."
                                )
                    else:
                        st.write("No parts available to enhance in this scene yet.")
                else:
                    st.write("No scenes available to enhance in this chapter yet.")
            else:
                st.write("No chapters with scene parts available to enhance yet.")

    if st.session_state.scene_parts_text:
        st.subheader("Scene Parts Text (Generated)")
        for (
            chapter_number,
            scene_parts_chapter,
        ) in st.session_state.scene_parts_text.items():
            st.markdown(f"**Chapter {chapter_number}**")
            for scene_number, scene_parts in scene_parts_chapter.items():
                st.markdown(f"  **Scene {scene_number}:**")
                for part_number, part_text in scene_parts.items():
                    st.markdown(f"    **Part {part_number}:**")
                    st.write(part_text)
```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/plot_outline_view.py`:

```````py
# streamlit_app/components/plot_outline_view.py
import streamlit as st
import asyncio
from core.plot_outline import PlotOutline
from typing import Optional
from core.content_generation.plot_outline_generator import PlotOutlineGenerator


def plot_outline_display(
    plot_outline: Optional[PlotOutline], plot_outline_generator: PlotOutlineGenerator
):
    """
    Displays the Plot Outline data, provides editing capabilities,
    and includes "Generate" and "Enhance" buttons with autosave.
    """
    st.subheader("Plot Outline")

    if not plot_outline:
        if st.button(
            "Generate Plot Outline",
            key="generate_plot_outline_button",
            disabled=st.session_state.plot_outline is not None
            or st.session_state.book_spec is None,
        ):
            if st.session_state.book_spec and plot_outline_generator:
                with st.spinner("Generating Plot Outline..."):
                    generated_outline = asyncio.run(
                        plot_outline_generator.generate(st.session_state.book_spec)
                    )
                if generated_outline:
                    st.session_state.plot_outline = generated_outline
                    # Autosave project after generation
                    st.session_state.project_manager.save_project(
                        st.session_state.project_name,
                        st.session_state.story_idea,
                        st.session_state.book_spec,
                        st.session_state.plot_outline,
                        st.session_state.chapter_outlines,
                        st.session_state.scene_outlines,
                        st.session_state.scene_parts,
                        st.session_state.scene_parts_text,
                        st.session_state.book_text,
                    )
                    st.success("Plot Outline Generated and Project Autosaved!")
                    st.rerun()
                else:
                    st.error("Failed to generate Plot Outline.")
            else:
                st.warning(
                    "Book Specification is required to generate Plot Outline. Please generate Book Spec first."
                )
    else:
        with st.expander("Edit Plot Outline", expanded=True):
            with st.form("plot_outline_form"):
                plot_outline.act_one = st.text_area(
                    "Act One: Setup",
                    plot_outline.act_one,
                    height=150,
                    key="act_one_input",
                )
                plot_outline.act_two = st.text_area(
                    "Act Two: Confrontation",
                    plot_outline.act_two,
                    height=200,
                    key="act_two_input",
                )
                plot_outline.act_three = st.text_area(
                    "Act Three: Resolution",
                    plot_outline.act_three,
                    height=150,
                    key="act_three_input",
                )

                col_save_enhance, _ = st.columns([3, 1])
                with col_save_enhance:
                    if st.form_submit_button(
                        "Save Plot Outline (Manual Edit)",
                        key="save_plot_outline_button",
                    ):
                        st.session_state.plot_outline = PlotOutline(
                            act_one=plot_outline.act_one,
                            act_two=plot_outline.act_two,
                            act_three=plot_outline.act_three,
                        )
                        # Autosave project after manual edit save
                        st.session_state.project_manager.save_project(
                            st.session_state.project_name,
                            st.session_state.story_idea,
                            st.session_state.book_spec,
                            st.session_state.plot_outline,
                            st.session_state.chapter_outlines,
                            st.session_state.scene_outlines,
                            st.session_state.scene_parts,
                            st.session_state.scene_parts_text,
                            st.session_state.book_text,
                        )
                        st.success(
                            "Plot Outline Saved (Manual Edit) and Project Autosaved!"
                        )
                with _:
                    if st.form_submit_button(
                        "Enhance Plot Outline", key="enhance_plot_outline_button"
                    ):
                        if plot_outline and plot_outline_generator:
                            with st.spinner("Enhancing Plot Outline..."):
                                enhanced_outline_raw = asyncio.run(
                                    plot_outline_generator.enhance(
                                        "\n".join(
                                            [
                                                "Act One:\n" + plot_outline.act_one,
                                                "Act Two:\n" + plot_outline.act_two,
                                                "Act Three:\n" + plot_outline.act_three,
                                            ]
                                        )
                                    )
                                )
                            if enhanced_outline_raw:
                                st.session_state.plot_outline = enhanced_outline_raw
                                # Autosave project after enhancement
                                st.session_state.project_manager.save_project(
                                    st.session_state.project_name,
                                    st.session_state.story_idea,
                                    st.session_state.book_spec,
                                    st.session_state.plot_outline,
                                    st.session_state.chapter_outlines,
                                    st.session_state.scene_outlines,
                                    st.session_state.scene_parts,
                                    st.session_state.scene_parts_text,
                                    st.session_state.book_text,
                                )
                                st.success(
                                    "Plot Outline Enhanced and Project Autosaved!"
                                )
                                st.rerun()
                            else:
                                st.error("Failed to enhance Plot Outline.")
                        else:
                            st.warning("No Plot Outline available to enhance.")

        st.write("Plot Outline:")
        if plot_outline:
            st.text(
                f"Act One: {plot_outline.act_one}\n\n"
                f"Act Two: {plot_outline.act_two}\n\n"
                f"Act Three: {plot_outline.act_three}"
            )
        else:
            st.info("No Plot Outline generated yet.")

```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/scene_outline_view.py`:

```````py
# streamlit_app/components/scene_outline_view.py
import streamlit as st
import asyncio
from core.plot_outline import SceneOutline
from typing import List, Optional, Dict
from core.content_generation.scene_outline_generator import SceneOutlineGenerator
import random


def scene_outlines_display(
    scene_outlines: Optional[Dict[int, List[SceneOutline]]],
    scene_outline_generator: SceneOutlineGenerator,
):
    """
    Displays SceneOutlines and provides UI for generation and enhancement
    with autosave functionality.
    """
    st.subheader("Scene Outlines")

    if not scene_outlines:
        max_scenes_per_chapter = st.number_input(
            "Maximum Scenes per Chapter",
            min_value=2,
            max_value=10,
            value=(
                st.session_state.max_scenes_per_chapter
                if "max_scenes_per_chapter" in st.session_state
                else 3
            ),
            key="max_scenes_per_chapter_input",
        )
        st.session_state.max_scenes_per_chapter = int(max_scenes_per_chapter)

        if st.button(
            "Generate Scene Outlines (All Chapters)",
            key="generate_all_scene_outlines_button",
            disabled=st.session_state.scene_outlines
            or not st.session_state.chapter_outlines,
        ):
            if st.session_state.chapter_outlines and scene_outline_generator:
                with st.spinner("Generating Scene Outlines for All Chapters..."):
                    generated_scene_outlines = {}
                    for chapter_outline in st.session_state.chapter_outlines:
                        num_scenes = random.randint(
                            2, st.session_state.max_scenes_per_chapter
                        )
                        chapter_scene_outlines = asyncio.run(
                            scene_outline_generator.generate(
                                chapter_outline, num_scenes
                            )
                        )
                        if chapter_scene_outlines:
                            generated_scene_outlines[chapter_outline.chapter_number] = (
                                chapter_scene_outlines
                            )
                    st.session_state.scene_outlines = generated_scene_outlines
                    # Autosave project after generation
                    st.session_state.project_manager.save_project(
                        st.session_state.project_name,
                        st.session_state.story_idea,
                        st.session_state.book_spec,
                        st.session_state.plot_outline,
                        st.session_state.chapter_outlines,
                        st.session_state.scene_outlines,
                        st.session_state.scene_parts,
                        st.session_state.scene_parts_text,
                        st.session_state.book_text,
                    )
                    st.success(
                        f"Scene Outlines Generated for All Chapters (up to {st.session_state.max_scenes_per_chapter} scenes per chapter) and Project Autosaved!"
                    )
                    st.rerun()
            else:
                st.error("Failed to generate Scene Outlines.")
        else:
            st.warning("Chapter Outlines are required to generate Scene Outlines.")

    else:
        for chapter_number, outlines in scene_outlines.items():
            with st.expander(
                f"Edit Scene Outlines - Chapter {chapter_number}", expanded=True
            ):
                edited_scene_outlines = [so.model_copy() for so in outlines]
                with st.form(f"scene_outlines_form_chapter_{chapter_number}"):
                    st.markdown(f"**Chapter {chapter_number}**")
                    for i, scene_outline in enumerate(edited_scene_outlines):
                        edited_summary = st.text_area(
                            f"Scene {i + 1} Outline",
                            scene_outline.summary,
                            height=80,
                            key=f"scene_outline_{chapter_number}_{i}",
                        )
                        edited_scene_outlines[i].summary = edited_summary

                    col1, col2 = st.columns([3, 1])
                    with col1:
                        if st.form_submit_button(
                            f"Save Scene Outlines (Manual Edit - Chapter {chapter_number})",
                            key=f"save_scene_outlines_chapter_{chapter_number}_button",
                        ):
                            st.session_state.scene_outlines[chapter_number] = (
                                edited_scene_outlines
                            )
                            # Autosave project after manual edit save
                            st.session_state.project_manager.save_project(
                                st.session_state.project_name,
                                st.session_state.story_idea,
                                st.session_state.book_spec,
                                st.session_state.plot_outline,
                                st.session_state.chapter_outlines,
                                st.session_state.scene_outlines,
                                st.session_state.scene_parts,
                                st.session_state.scene_parts_text,
                                st.session_state.book_text,
                            )
                            st.success(
                                f"Scene Outlines Saved (Manual Edit - Chapter {chapter_number}) and Project Autosaved!"
                            )
                    with col2:
                        if st.form_submit_button(
                            f"Enhance Scene Outlines (Chapter {chapter_number})",
                            key=f"enhance_scene_outlines_chapter_{chapter_number}_button",
                        ):
                            if scene_outline_generator:
                                with st.spinner(
                                    f"Enhancing Scene Outlines for Chapter {chapter_number}..."
                                ):
                                    enhanced_scene_outlines = asyncio.run(
                                        scene_outline_generator.enhance(
                                            edited_scene_outlines
                                        )
                                    )
                                if enhanced_scene_outlines:
                                    st.session_state.scene_outlines[chapter_number] = (
                                        enhanced_scene_outlines
                                    )
                                    # Autosave project after enhancement
                                    st.session_state.project_manager.save_project(
                                        st.session_state.project_name,
                                        st.session_state.story_idea,
                                        st.session_state.book_spec,
                                        st.session_state.plot_outline,
                                        st.session_state.chapter_outlines,
                                        st.session_state.scene_outlines,
                                        st.session_state.scene_parts,
                                        st.session_state.scene_parts_text,
                                        st.session_state.book_text,
                                    )
                                    st.success(
                                        f"Scene Outlines Enhanced for Chapter {chapter_number} and Project Autosaved!"
                                    )
                                    st.rerun()
                                else:
                                    st.error(
                                        f"Failed to enhance Scene Outlines for Chapter {chapter_number}."
                                    )
                            else:
                                st.error("Scene Outline Generator not initialized.")

            st.markdown(f"**Chapter {chapter_number} Scenes:**")
            for scene_outline in outlines:
                st.markdown(f"  **Scene {scene_outline.scene_number}:**")
                st.write(scene_outline.summary)

```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/book_text_view.py`:

```````py
# streamlit_app/components/book_text_view.py
import streamlit as st
from typing import Optional, Dict
import zipfile
import io
import re  # Import the regular expression library


def book_text_display(book_text: Optional[str]):
    """
    Displays the assembled book text and provides a save function
    to save the book in markdown format (chapters in separate files, zipped),
    using the book title for naming.
    """
    st.subheader("Generated Book Text")
    if book_text:
        st.markdown(book_text)

        if st.button("Save Book as Markdown"):
            if (
                book_text and st.session_state.book_spec
            ):  # Ensure book_text and book_spec are available
                book_title = st.session_state.book_spec.title
                if not book_title:
                    book_title = (
                        "untitled_book"  # Default title if book_spec.title is missing
                    )
                else:
                    book_title = sanitize_filename(
                        book_title
                    )  # Sanitize title for filename

                # Split book text into chapters
                chapters = split_book_into_chapters(book_text)

                # Create in-memory zip file
                zip_buffer = io.BytesIO()
                with zipfile.ZipFile(zip_buffer, "w") as zipf:
                    for chapter_num, chapter_text in chapters.items():
                        # Create markdown file for each chapter in memory
                        chapter_markdown = io.StringIO()
                        chapter_markdown.write(chapter_text)
                        chapter_filename = f"{book_title}_chapter_{chapter_num}.md"  # Filename with book title
                        zipf.writestr(chapter_filename, chapter_markdown.getvalue())

                zip_file = zip_buffer.getvalue()

                st.download_button(
                    label="Download Book Chapters (ZIP)",
                    data=zip_file,
                    file_name=f"{book_title}_chapters.zip",  # Zip filename with book title
                    mime="application/zip",
                    on_click=None,
                    disabled=False,
                )
            else:
                st.warning(
                    "No book text or book specification available to save."
                )  # Inform user if book_spec is missing

    else:
        st.info(
            "No book text generated yet. Generate scene parts and assemble the book to view it here."
        )


def split_book_into_chapters(book_text: str) -> Dict[int, str]:
    """
    Splits the full book text into a dictionary of chapters,
    keyed by chapter number.
    """
    chapters = {}
    chapter_split = book_text.split("# Chapter ")
    for i, chapter_content in enumerate(
        chapter_split[1:], start=1
    ):  # Start from 1 to skip preamble and number chapters from 1
        chapter_number_str, chapter_text = chapter_content.split(
            "\n", 1
        )  # split at the first newline to separate chapter number from text
        try:
            chapter_number = int(
                chapter_number_str.strip()
            )  # chapter number is the first line
        except ValueError:
            chapter_number = (
                i  # if chapter number is not properly parsed, use index as fallback
            )
        chapters[chapter_number] = (
            f"# Chapter {chapter_number}\n" + chapter_text.strip()
        )  # Re-add chapter heading to each chapter

    return chapters


def sanitize_filename(title: str) -> str:
    """
    Sanitizes a string to be used as a filename by replacing spaces and
    non-alphanumeric characters with underscores.
    """
    sanitized_title = re.sub(r"\s+", "_", title)  # Replace spaces with underscores
    sanitized_title = re.sub(
        r"[^\w.-]", "", sanitized_title
    )  # Remove non-alphanumeric, period, hyphen chars
    return sanitized_title

```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/__init__.py`:

```````py
# streamlit_app/components/__init__.py

"""
Package initializer for the streamlit_app.components package.

This package is intended to house reusable Streamlit components 
for the Fiction Fabricator application. 

Currently, it is minimally populated as the application's UI 
is primarily managed within app.py. However, this package is 
structured to facilitate future expansion and organization 
of UI elements into reusable components, should the complexity 
of the application grow.

As the application evolves, specific UI components like custom 
input forms, display panels, or interactive elements can be 
modularized and placed within this package to improve code 
organization and maintainability of the Streamlit application.
"""

```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/components/chapter_outline_view.py`:

```````py
# streamlit_app/components/chapter_outline_view.py
import streamlit as st
import asyncio
from core.plot_outline import ChapterOutline
from typing import List, Optional
from core.content_generation.chapter_outline_generator import ChapterOutlineGenerator


def chapter_outlines_display(
    chapter_outlines: Optional[List[ChapterOutline]],
    chapter_outline_generator: ChapterOutlineGenerator,
):
    """
    Displays ChapterOutlines and provides UI for generation and enhancement
    with autosave functionality.
    """
    st.subheader("Chapter Outlines")

    if not chapter_outlines:
        num_chapters = st.number_input(
            "Number of Chapters",
            min_value=3,
            max_value=50,
            value=(
                st.session_state.num_chapters
                if "num_chapters" in st.session_state
                else 10
            ),
            key="num_chapters_input",
        )
        st.session_state.num_chapters = int(num_chapters)
        if st.button(
            "Generate Chapter Outlines",
            disabled=st.session_state.chapter_outlines
            or not st.session_state.plot_outline,
            key="generate_chapter_outlines_button",
        ):
            if st.session_state.plot_outline and chapter_outline_generator:
                with st.spinner("Generating Chapter Outlines..."):
                    generated_outlines = asyncio.run(
                        chapter_outline_generator.generate(
                            st.session_state.plot_outline, st.session_state.num_chapters
                        )
                    )
                if generated_outlines:
                    st.session_state.chapter_outlines = generated_outlines
                    # Autosave project after generation
                    st.session_state.project_manager.save_project(
                        st.session_state.project_name,
                        st.session_state.story_idea,
                        st.session_state.book_spec,
                        st.session_state.plot_outline,
                        st.session_state.chapter_outlines,
                        st.session_state.scene_outlines,
                        st.session_state.scene_parts,
                        st.session_state.scene_parts_text,
                        st.session_state.book_text,
                    )
                    st.success(
                        f"Chapter Outlines Generated for {len(st.session_state.chapter_outlines)} chapters and Project Autosaved!"
                    )
                    st.rerun()
                else:
                    st.error("Failed to generate Chapter Outlines.")
            else:
                st.warning("Plot Outline is required to generate Chapter Outlines.")

    else:
        with st.expander("Edit Chapter Outlines", expanded=True):
            edited_chapter_outlines = [co.model_copy() for co in chapter_outlines]
            with st.form("chapter_outlines_form"):
                for i, chapter_outline in enumerate(edited_chapter_outlines):
                    st.markdown(f"**Chapter {chapter_outline.chapter_number}:**")
                    edited_summary = st.text_area(
                        "Summary",
                        chapter_outline.summary,
                        height=100,
                        key=f"chapter_{i}_summary",
                    )
                    edited_chapter_outlines[i].summary = edited_summary

                col1, col2 = st.columns([3, 1])
                with col1:
                    if st.form_submit_button(
                        "Save Chapter Outlines (Manual Edit)",
                        key="save_chapter_outlines_button",
                    ):
                        st.session_state.chapter_outlines = edited_chapter_outlines
                        # Autosave project after manual edit save
                        st.session_state.project_manager.save_project(
                            st.session_state.project_name,
                            st.session_state.story_idea,
                            st.session_state.book_spec,
                            st.session_state.plot_outline,
                            st.session_state.chapter_outlines,
                            st.session_state.scene_outlines,
                            st.session_state.scene_parts,
                            st.session_state.scene_parts_text,
                            st.session_state.book_text,
                        )
                        st.success(
                            "Chapter Outlines Saved (Manual Edit) and Project Autosaved!"
                        )
                with col2:
                    if st.form_submit_button(
                        "Enhance Chapter Outlines",
                        key="enhance_chapter_outlines_button",
                    ):
                        with st.spinner("Enhancing Chapter Outlines..."):
                            enhanced_chapter_outlines = asyncio.run(
                                chapter_outline_generator.enhance(
                                    edited_chapter_outlines
                                )
                            )
                        if enhanced_chapter_outlines:
                            st.session_state.chapter_outlines = (
                                enhanced_chapter_outlines
                            )
                            # Autosave project after enhancement
                            st.session_state.project_manager.save_project(
                                st.session_state.project_name,
                                st.session_state.story_idea,
                                st.session_state.book_spec,
                                st.session_state.plot_outline,
                                st.session_state.chapter_outlines,
                                st.session_state.scene_outlines,
                                st.session_state.scene_parts,
                                st.session_state.scene_parts_text,
                                st.session_state.book_text,
                            )
                            st.success(
                                "Chapter Outlines Enhanced and Project Autosaved!"
                            )
                            st.rerun()
                        else:
                            st.error("Failed to enhance Chapter Outlines.")

        for chapter_outline in chapter_outlines:
            st.markdown(f"**Chapter {chapter_outline.chapter_number}:**")
            st.write(chapter_outline.summary)

```````

`/home/tlh/refactored_gui_fict_fab/streamlit_app/__init__.py`:

```````py
# streamlit_app/__init__.py

"""
Package initializer for the streamlit_app package.

This package contains all the modules and components for the Streamlit
web application of the Fiction Fabricator. It is responsible for:

- app.py: The main script for running the Streamlit application. 
  This file sets up the user interface, manages application state, 
  and orchestrates the content generation workflow.
- components/: A directory intended to house reusable Streamlit 
  components. While currently minimally used, this structure is in 
  place for future expansion and organization of UI elements. 

The streamlit_app package is the primary user interface for the 
Fiction Fabricator, providing an interactive and visual way for users 
to create and refine their fictional content.
"""

```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/plot_outline_generator.py`:

```````py
# core/content_generation/plot_outline_generator.py
from typing import Optional

from core.book_spec import BookSpec
from core.content_generation.base_generator import BaseContentGenerator
from core.plot_outline import PlotOutline
from llm.prompt_manager.plot_outline_prompts import PlotOutlinePrompts
from utils.logger import logger


class PlotOutlineGenerator(BaseContentGenerator):
    """
    Content generator for PlotOutline objects.

    Inherits from BaseContentGenerator and provides specific functionality
    for generating and enhancing plot outlines.
    """

    def __init__(self, prompt_manager, model_name: str):
        """
        Initializes PlotOutlineGenerator with prompt manager and model name.
        """
        super().__init__(prompt_manager, model_name)
        self.prompts = PlotOutlinePrompts(
            prompt_manager
        )  # Initialize plot outline specific prompts

    async def generate(self, book_spec: BookSpec) -> Optional[PlotOutline]:
        """
        Generates a PlotOutline based on a BookSpec.
        """
        generation_prompt_template = (
            self.prompts.create_plot_outline_generation_prompt()
        )
        variables = {"book_spec_json": book_spec.model_dump_json(indent=4)}
        generated_text = await self._generate_content_from_prompt(
            generation_prompt_template, variables
        )
        if not generated_text:
            return None

        structure_check_prompt_template = (
            self.prompts.create_plot_outline_structure_check_prompt()
        )
        structure_fix_prompt_template = (
            self.prompts.create_plot_outline_structure_fix_prompt()
        )
        validated_text = await self._structure_check_and_fix(
            generated_text,
            structure_check_prompt_template,
            structure_fix_prompt_template,
        )
        if not validated_text:
            return None

        return self._parse_response(validated_text)

    async def enhance(
        self, current_content: PlotOutline
    ) -> Optional[PlotOutline]:  # Parameter name consistent with base class
        """
        Enhances an existing plot outline.
        """
        critique_prompt_template = self.prompts.create_plot_outline_critique_prompt()
        rewrite_prompt_template = self.prompts.create_plot_outline_rewrite_prompt()
        variables = {
            "current_outline": "\n".join(
                [
                    f"Act One:\n{current_content.act_one}",
                    f"Act Two:\n{current_content.act_two}",
                    f"Act Three:\n{current_content.act_three}",
                ]
            )
        }  # Pass string for critique

        critique_text = await self._generate_content_from_prompt(
            critique_prompt_template, variables
        )
        if not critique_text:
            return None

        rewrite_variables = {**variables, "critique": critique_text}
        enhanced_outline_text = await self._generate_content_from_prompt(
            rewrite_prompt_template, rewrite_variables
        )
        if not enhanced_outline_text:
            return None

        return self._parse_response(enhanced_outline_text)

    def _parse_response(self, response_text: str) -> Optional[PlotOutline]:
        """
        Parses the LLM response text into a PlotOutline object.
        """
        try:
            plot_outline = PlotOutline(act_one="", act_two="", act_three="")
            acts = response_text.split("Act ")
            if len(acts) >= 4:
                plot_outline.act_one = acts[1].split("Act")[0].strip()
                plot_outline.act_two = acts[2].split("Act")[0].strip()
                plot_outline.act_three = acts[3].strip()
            else:
                logger.warning(
                    "Unexpected plot outline format from LLM, basic parsing failed."
                )
                plot_outline.act_one = (
                    response_text  # Fallback: use the whole response as act_one
                )
            return plot_outline
        except (
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:  # More specific exception catching
            logger.error("Error parsing PlotOutline response: %s", e)  # Lazy format
            logger.debug("Raw LLM response: %s", response_text)  # Lazy format
            logger.exception(e)  # Log full exception details
            return None

```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/scene_outline_generator.py`:

```````py
# core/content_generation/scene_outline_generator.py
from typing import List, Optional

from core.content_generation.base_generator import BaseContentGenerator
from core.plot_outline import ChapterOutline, SceneOutline
from llm.prompt_manager.scene_outline_prompts import SceneOutlinePrompts
from utils.logger import logger


class SceneOutlineGenerator(BaseContentGenerator):
    """
    Content generator for SceneOutline objects.

    Inherits from BaseContentGenerator and specializes in generating
    and enhancing scene outlines for each chapter.
    """

    def __init__(self, prompt_manager, model_name: str):
        """
        Initializes SceneOutlineGenerator with prompt manager and model name.
        """
        super().__init__(prompt_manager, model_name)
        self.prompts = SceneOutlinePrompts(
            prompt_manager
        )  # Initialize scene outline specific prompts

    async def generate(
        self, chapter_outline: ChapterOutline, num_scenes: int
    ) -> Optional[List[SceneOutline]]:
        """
        Generates a list of SceneOutlines for a given ChapterOutline.
        """
        generation_prompt_template = (
            self.prompts.create_scene_outlines_generation_prompt()
        )
        variables = {
            "chapter_outline": chapter_outline.summary,
            "num_scenes_per_chapter": str(num_scenes),
        }
        generated_text = await self._generate_content_from_prompt(
            generation_prompt_template, variables
        )
        if not generated_text:
            return None

        structure_check_prompt_template = (
            self.prompts.create_scene_outlines_structure_check_prompt()
        )
        structure_fix_prompt_template = (
            self.prompts.create_scene_outlines_structure_fix_prompt()
        )
        validated_text = await self._structure_check_and_fix(
            generated_text,
            structure_check_prompt_template,
            structure_fix_prompt_template,
        )
        if not validated_text:
            return None

        return self._parse_response(validated_text)

    async def enhance(
        self,
        current_content: List[
            SceneOutline
        ],  # Parameter name consistent with base class
    ) -> Optional[List[SceneOutline]]:
        """
        Enhances a list of existing SceneOutline objects.
        """
        # Convert SceneOutline objects to text for critique and rewrite prompts
        outline_texts = [
            f"Scene {so.scene_number}:\n{so.summary}" for so in current_content
        ]
        current_outlines_text = "\n\n".join(outline_texts)

        critique_prompt_template = self.prompts.create_scene_outlines_critique_prompt()
        rewrite_prompt_template = self.prompts.create_scene_outlines_rewrite_prompt()
        variables = {"current_outlines": current_outlines_text}

        critique_text = await self._generate_content_from_prompt(
            critique_prompt_template, variables
        )
        if not critique_text:
            return None

        rewrite_variables = {**variables, "critique": critique_text}
        enhanced_outlines_text = await self._generate_content_from_prompt(
            rewrite_prompt_template, rewrite_variables
        )
        if not enhanced_outlines_text:
            return None

        # Parse and return enhanced scene outlines
        return self._parse_response(enhanced_outlines_text)

    def _parse_response(self, response_text: str) -> Optional[List[SceneOutline]]:
        """
        Parses the LLM response text into a list of SceneOutline objects.
        """
        scene_outlines: List[SceneOutline] = []
        try:
            scene_splits = response_text.strip().split("Scene ")
            for i, scene_text in enumerate(scene_splits[1:], start=1):
                scene_summary = scene_text.split("Scene")[
                    0
                ].strip()  # Split again in case "Scene" is in summary text
                if scene_summary:
                    scene_outlines.append(
                        SceneOutline(scene_number=i, summary=scene_summary)
                    )
                else:
                    logger.warning(
                        "Skipping empty scene outline in LLM response."
                    )  # No lazy format - simple string
                    # logger.warning("%s", "Skipping empty scene outline in LLM response.") # Lazy format - but no variable to pass

            if not scene_outlines:
                logger.error(
                    "No scene outlines parsed from LLM response."
                )  # No lazy format - simple string
                # logger.error("%s", "No scene outlines parsed from LLM response.") # Lazy format - but no variable to pass
                return None
            return scene_outlines

        except (
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:  # Specific exception handling
            logger.error("Error parsing SceneOutline responses: %s", e)  # Lazy format
            logger.debug("Raw LLM response: %s", response_text)  # Lazy format
            logger.exception(e)  # Log full exception details
            return None

```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/chapter_outline_generator.py`:

```````py
# core/content_generation/chapter_outline_generator.py
from typing import List, Optional

from core.content_generation.base_generator import BaseContentGenerator
from core.plot_outline import ChapterOutline, PlotOutline
from llm.prompt_manager.chapter_outline_prompts import ChapterOutlinePrompts
from utils.logger import logger


class ChapterOutlineGenerator(BaseContentGenerator):
    """
    Content generator for ChapterOutline objects.

    Extends BaseContentGenerator to provide specific functionality for
    generating and enhancing chapter outlines for a novel.
    """

    def __init__(self, prompt_manager, model_name: str):
        """
        Initializes ChapterOutlineGenerator with prompt manager and model name.
        """
        super().__init__(prompt_manager, model_name)
        self.prompts = ChapterOutlinePrompts(
            prompt_manager
        )  # Initialize chapter outline specific prompts

    async def generate(
        self, plot_outline: PlotOutline, num_chapters: int
    ) -> Optional[List[ChapterOutline]]:
        """
        Generates a list of ChapterOutlines based on a PlotOutline.
        """
        generation_prompt_template = (
            self.prompts.create_chapter_outlines_generation_prompt()
        )
        variables = {
            "plot_outline": "\n".join(
                [
                    "Act One:\n" + plot_outline.act_one,
                    "Act Two:\n" + plot_outline.act_two,
                    "Act Three:\n" + plot_outline.act_three,
                ]
            ),
            "num_chapters": str(num_chapters),
        }
        generated_text = await self._generate_content_from_prompt(
            generation_prompt_template, variables
        )
        if not generated_text:
            return None

        structure_check_prompt_template = (
            self.prompts.create_chapter_outlines_structure_check_prompt()
        )
        structure_fix_prompt_template = (
            self.prompts.create_chapter_outlines_structure_fix_prompt()
        )
        validated_text = await self._structure_check_and_fix(
            generated_text,
            structure_check_prompt_template,
            structure_fix_prompt_template,
        )
        if not validated_text:
            return None

        return self._parse_response(validated_text, num_chapters)

    async def enhance(
        self,
        current_content: List[
            ChapterOutline
        ],  # Parameter name consistent with base class
    ) -> Optional[List[ChapterOutline]]:
        """
        Enhances a list of existing ChapterOutline objects.
        """
        # Convert ChapterOutline objects to text for critique and rewrite prompts
        outline_texts = [
            f"Chapter {co.chapter_number}:\n{co.summary}" for co in current_content
        ]
        current_outlines_text = "\n\n".join(outline_texts)

        critique_prompt_template = (
            self.prompts.create_chapter_outlines_critique_prompt()
        )
        rewrite_prompt_template = self.prompts.create_chapter_outlines_rewrite_prompt()
        variables = {"current_outlines": current_outlines_text}

        critique_text = await self._generate_content_from_prompt(
            critique_prompt_template, variables
        )
        if not critique_text:
            return None

        rewrite_variables = {**variables, "critique": critique_text}
        enhanced_outlines_text = await self._generate_content_from_prompt(
            rewrite_prompt_template, rewrite_variables
        )
        if not enhanced_outlines_text:
            return None

        # Parse and return enhanced chapter outlines
        return self._parse_response(enhanced_outlines_text, len(current_content))

    def _parse_response(
        self, response_text: str, num_chapters: int
    ) -> Optional[List[ChapterOutline]]:
        """
        Parses the LLM response text into a list of ChapterOutline objects.
        """
        chapter_outlines: List[ChapterOutline] = []
        try:
            chapter_splits = response_text.strip().split("Chapter ")
            logger.debug(
                "Number of chapter splits found: %s, expected chapters: %s",
                len(chapter_splits) - 1,
                num_chapters,  # Lazy format
            )
            for i, chapter_text in enumerate(
                chapter_splits[1:], start=1
            ):  # Start from 1 to skip intro, enumerate for chapter number
                if i > num_chapters:
                    logger.warning(
                        "Parsed more chapters than requested (%s). Stopping after %s chapters.",
                        num_chapters,
                        num_chapters,  # Lazy format
                    )
                    break  # Limit chapters to requested number

                chapter_summary = chapter_text.split("Chapter")[
                    0
                ].strip()  # Split again in case "Chapter" is in summary text
                if chapter_summary:
                    chapter_outlines.append(
                        ChapterOutline(chapter_number=i, summary=chapter_summary)
                    )
                    logger.debug(
                        "Parsed chapter %s outline: %s...",
                        i,
                        chapter_summary[:50],  # Lazy format
                    )
            if not chapter_outlines:
                logger.error("No chapter outlines parsed from LLM response.")
                return None
            return chapter_outlines

        except (
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:  # More specific exception catching
            logger.error("Error parsing ChapterOutline responses: %s", e)  # Lazy format
            logger.debug("Raw LLM response: %s", response_text)  # Lazy format
            logger.exception(e)  # Log full exception details
            return None

```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/book_assembler.py`:

```````py
# core/content_generation/book_assembler.py
from typing import Dict


class BookAssembler:
    """
    Assembles the generated scene parts into a complete book text, ordered by chapter, scene, and part number.
    """

    def assemble_book_text(
        self, scene_parts_text: Dict[int, Dict[int, Dict[int, str]]]
    ) -> str:
        """
        Assembles scene parts into a formatted book text.
        """
        full_book_text = ""
        for chapter_num in sorted(scene_parts_text.keys()):
            full_book_text += f"# Chapter {chapter_num}\n\n"  # Chapter heading

            scene_parts_chapter = scene_parts_text[chapter_num]
            for scene_num in sorted(scene_parts_chapter.keys()):
                full_book_text += f"## Scene {scene_num}\n\n"  # Scene heading

                scene_parts = scene_parts_chapter[scene_num]
                for part_num in sorted(scene_parts.keys()):
                    part_text = scene_parts[part_num]
                    full_book_text += part_text + "\n\n"  # Add part text and spacing

        return full_book_text.strip()  # Remove leading/trailing whitespace

```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/book_spec_generator.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/core/content_generation/book_spec_generator.py
import json
from typing import Optional

from pydantic import ValidationError

from core.book_spec import BookSpec
from core.content_generation.base_generator import BaseContentGenerator
from llm.prompt_manager.prompt_manager import DynamicPromptManager # type: ignore
from utils.logger import logger


class BookSpecGenerator(BaseContentGenerator):
    """
    Content generator for BookSpec objects.
    """

    def __init__(self, prompt_manager, model_name: str):
        """
        Initializes BookSpecGenerator with prompt manager and model name.
        """
        super().__init__(prompt_manager, model_name)
        self.prompts = prompt_manager
        logger.debug("prompt: %s...", self.prompts)

    async def generate(
        self, idea: str, project_name: str = "Untitled"
    ) -> Optional[BookSpec]:  # Add type hint for the return type
        """
        Generates a BookSpec based on a story idea.
        """
        logger.debug(f"Generating BookSpec with idea: {idea}, project_name: {project_name}") # Log input

        generation_prompt_template = self.prompts.get_prompt("book_spec_generation_prompt")
        logger.debug("generation_prompt_template: %s...", generation_prompt_template)

        variables = {"idea": idea, "project_name": project_name}
        logger.debug(f"Prompt variables: {variables}") # Log variables BEFORE formatting

        try: # Add try-except around prompt formatting
            formatted_prompt = generation_prompt_template.format(**variables) # Format prompt HERE
            logger.debug(f"Formatted prompt (first 200 chars): {formatted_prompt[:200]}...") # Log formatted prompt
        except KeyError as e:
            logger.error(f"KeyError during prompt formatting: {e}") # More specific error log
            logger.error(f"Prompt template: {generation_prompt_template}") # Log template on error
            logger.error(f"Variables: {variables}") # Log variables on error
            return None # Return None on formatting error


        generated_text = await self._generate_content_from_prompt(
            formatted_prompt, {} # Use formatted_prompt, no need to pass variables again
        )
        if not generated_text:
            logger.error("Initial content generation failed.")
            return None


        book_spec = self._parse_response(generated_text)
        if not book_spec:
            logger.error("Parsing failed.")
            return None

        logger.debug("Parsing successful.  Returning BookSpec.")
        return book_spec

    async def enhance(
        self, current_content: BookSpec, enhance_target: str
    ) -> Optional[BookSpec]:  # Renamed parameter to current_content
        """
        Enhances an existing BookSpec object.
        """
        critique_prompt_template = self.prompts.get_prompt("book_spec_critique_prompt")
        rewrite_prompt_template = self.prompts.get_prompt("book_spec_rewrite_prompt")
        variables = {
            "title": current_content.title,
            "genre": current_content.genre,
            "setting": current_content.setting,
            "themes": ", ".join(current_content.themes),
            "tone": current_content.tone,
            "point_of_view": current_content.point_of_view,
            "characters": ", ".join(current_content.characters),
            "premise": current_content.premise
        }  # Now using current_content

        critique_text = await self._generate_content_from_prompt(
            critique_prompt_template, variables
        )
        if not critique_text:
            return None

        rewrite_variables = {**variables, "critique": critique_text}
        enhanced_spec_json = await self._generate_content_from_prompt(
            rewrite_prompt_template, rewrite_variables
        )
        if not enhanced_spec_json:
            return None

        return self._parse_response(enhanced_spec_json)

    def _parse_response(self, response_text: str) -> Optional[BookSpec]:
        """
        Parses the JSON response from the LLM and validates it against the BookSpec model.
        """
        try:
            book_spec_data = json.loads(response_text)
            return BookSpec(**book_spec_data)
        except json.JSONDecodeError as e:
            logger.error("JSONDecodeError: %s", e)  # Lazy format
            logger.debug("Problematic JSON string: %s", response_text)  # Lazy format
            return None
        except ValidationError as e:
            logger.error("ValidationError: %s", e)  # Lazy format
            logger.debug(
                "Problematic JSON data: %s",
                (
                    book_spec_data
                    if "book_spec_data" in locals()
                    else "JSON data not parsed"
                ),
            )  # Lazy format
            return None
        except (
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:  # Catch specific operational errors
            logger.error(
                "Operational error during parsing BookSpec JSON: %s", e
            )  # Lazy format
            logger.exception(e)  # Log full exception details
            return None
```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/base_generator.py`:

```````py
# core/content_generation/base_generator.py
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional

import json
import aiohttp

from llm.llm_client import OpenAILLMClient  # Changed to OpenAILLMClient
from utils.logger import logger


class BaseContentGenerator(ABC):
    """
    Abstract base class for content generators.

    Defines a common interface and implements shared functionalities
    for all content generator classes.
    """

    def __init__(self, prompt_manager, model_name: str):
        """
        Initializes the BaseContentGenerator with a prompt manager and model name.
        """
        self.prompt_manager = prompt_manager
        self.model_name = model_name
        self.openai_client = OpenAILLMClient()  # Changed to OpenAILLMClient

    @abstractmethod
    async def generate(self, *args: Any, **kwargs: Any) -> Optional[Any]:
        """
        Abstract method for generating content. Must be implemented by subclasses.
        """

    @abstractmethod
    async def enhance(self, current_content: Any) -> Optional[Any]:
        """
        Abstract method for enhancing existing content. Must be implemented by subclasses.
        """

    async def _generate_content_from_prompt(
        self, prompt_template: str, variables: Dict[str, str]
    ) -> Optional[str]:
        """
        Handles content generation from a prompt template using Ollama with lazy logging and specific exception handling.
        """
        try:
            prompt = prompt_template.format(**variables)
            logger.debug("Generated Prompt: %s...", prompt[:150])  # Lazy formatting
            generated_text = await self.openai_client.generate_text(
                model_name=self.model_name, prompt=prompt
            )  # Changed to openai_client
            if generated_text:
                return generated_text
            else:
                logger.error("LLM text generation failed or returned empty response.")
                return None

        except KeyError as e:  # Catch specific KeyError for prompt formatting issues
            logger.error(
                "Error formatting prompt due to missing variable: %s", e
            )  # Lazy formatting
            return None
        except (
            aiohttp.ClientError
        ) as e:  # Catch specific aiohttp ClientError for network/API issues
            logger.error(
                "Error during OpenAI API call: %s", e
            )  # Changed error message
            return None
        except json.JSONDecodeError as e:  # Catch specific JSONDecodeError for invalid JSON
            logger.error(
                "OpenAI response JSON decoding error: %s", e
            )  # Changed error message
            return None
        except (
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:  # Catch specific operational errors
            logger.error(
                "Operational error during content generation: %s", e
            )  # Lazy formatting
            logger.exception(e)  # Log full exception details for unexpected errors
            return None

    @abstractmethod
    def _parse_response(self, response_text: str) -> Any:
        """
        Abstract method to parse the LLM response. Must be implemented by subclasses.
        """

    async def _structure_check_and_fix(
        self,
        content: str,
        structure_check_prompt_template: str,
        structure_fix_prompt_template: str,
    ) -> Optional[str]:
        """
        Implements structure checking and fixing logic using LLM prompts.
        """
        structure_check_variables = {"content": content}
        structure_check_result = await self._generate_content_from_prompt(
            structure_check_prompt_template, structure_check_variables
        )

        if structure_check_result != "STRUCTURE_OK":
            logger.warning("Content structure check failed. Attempting to fix...")
            structure_fix_variables = {
                "content_with_structure_problems": content,
                "structure_problems": structure_check_result,
            }
            fixed_text = await self._generate_content_from_prompt(
                structure_fix_prompt_template, structure_fix_variables
            )
            if fixed_text:
                logger.info("Content structure fixed successfully.")
                return fixed_text
            else:
                logger.error("Failed to fix content structure.")
                return None
        else:
            logger.info("Content structure check OK.")
            return content
```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/scene_part_generator.py`:

```````py
# core/content_generation/scene_part_generator.py
from typing import Optional

from core.content_generation.base_generator import BaseContentGenerator
from core.plot_outline import SceneOutline, ChapterOutline
from core.book_spec import BookSpec
from llm.prompt_manager.scene_part_prompts import ScenePartPrompts
from utils.logger import logger


class ScenePartGenerator(BaseContentGenerator):
    """
    Content generator for scene parts, which are sections of text within a scene.

    Inherits from BaseContentGenerator and provides functionality to generate
    and enhance individual parts of a scene's narrative.
    """

    def __init__(self, prompt_manager, model_name: str):
        """
        Initializes ScenePartGenerator with prompt manager and model name.
        """
        super().__init__(prompt_manager, model_name)
        self.prompts = ScenePartPrompts(
            prompt_manager
        )  # Initialize scene part specific prompts

    async def generate(
        self,
        scene_outline: SceneOutline,
        part_number: int,
        book_spec: BookSpec,
        chapter_outline: ChapterOutline,
        scene_outline_full: SceneOutline,
    ) -> Optional[str]:
        """
        Generates a part of a scene's text content.
        """
        generation_prompt_template = self.prompts.create_scene_part_generation_prompt()
        variables = {
            "scene_outline": scene_outline.summary,
            "part_number": str(part_number),
            "book_spec_text": book_spec.model_dump_json(indent=4),
            "chapter_outline": chapter_outline.summary,
            "scene_outline_full": scene_outline_full.summary,
        }
        generated_text = await self._generate_content_from_prompt(
            generation_prompt_template, variables
        )
        if not generated_text:
            return None

        structure_check_prompt_template = (
            self.prompts.create_scene_part_structure_check_prompt()
        )
        structure_fix_prompt_template = (
            self.prompts.create_scene_part_structure_fix_prompt()
        )
        validated_text = await self._structure_check_and_fix(
            generated_text,
            structure_check_prompt_template,
            structure_fix_prompt_template,
        )
        if not validated_text:
            return None

        return self._parse_response(validated_text)

    async def enhance(
        self,
        current_content: str,  # Parameter name consistent with base class - now current_content
        part_number: int,
        book_spec: BookSpec,
        chapter_outline: ChapterOutline,
        scene_outline_full: SceneOutline,
    ) -> Optional[str]:
        """
        Enhances an existing scene part's text content.
        """
        critique_prompt_template = self.prompts.create_scene_part_critique_prompt()
        rewrite_prompt_template = self.prompts.create_scene_part_rewrite_prompt()
        variables = {
            "book_spec": book_spec.model_dump_json(indent=4),
            "chapter_outline": chapter_outline.summary,
            "scene_outline_full": scene_outline_full.summary,
            "part_number": str(part_number),
        }
        critique_variables = {
            **variables,
            "content": current_content,
        }  # Now using current_content

        critique_text = await self._generate_content_from_prompt(
            critique_prompt_template, critique_variables
        )
        if not critique_text:
            return None

        rewrite_variables = {
            **variables,
            "critique": critique_text,
            "content": current_content,  # Now using current_content
        }
        enhanced_part_text = await self._generate_content_from_prompt(
            rewrite_prompt_template, rewrite_variables
        )
        if not enhanced_part_text:
            return None

        return self._parse_response(enhanced_part_text)

    def _parse_response(self, response_text: str) -> Optional[str]:
        """
        Parses the LLM response text for a scene part.
        """
        if (
            response_text and response_text.strip()
        ):  # Check for non-empty and non-whitespace
            return response_text.strip()  # Return text content, stripping whitespace
        else:
            logger.warning(
                "LLM response for scene part was empty or only whitespace."
            )  # warning style

            return None  # Handle empty or whitespace-only response

```````

`/home/tlh/refactored_gui_fict_fab/core/content_generation/__init__.py`:

```````py
# core/content_generator/__init__.py

"""
Package initializer for the content_generator package.

This package is responsible for generating different types of content
for the Fiction Fabricator application, including:

- Book Specifications (book_spec_generator.py)
- Plot Outlines (plot_outline_generator.py)
- Chapter Outlines (chapter_outline_generator.py)
- Scene Outlines (scene_outline_generator.py)
- Scene Parts (scene_part_generator.py)

It also provides a base class, BaseContentGenerator (base_generator.py), 
which defines common functionalities and an interface for all content generators 
within this package, promoting code reuse and consistency.
"""

```````

`/home/tlh/refactored_gui_fict_fab/core/book_spec.py`:

```````py
# core/book_spec.py
from pydantic import BaseModel


class BookSpec(BaseModel):
    """
    Represents the specification for a novel.

    This Pydantic model defines the structure for storing and validating
    the book specification, including title, genre, setting, themes, tone,
    point of view, characters, and premise.
    """

    title: str
    """The title of the novel."""
    genre: str
    """The genre and subgenres of the novel (e.g., Dark Fantasy, Erotic Thriller)."""
    setting: str
    """Detailed description of the novel's setting(s), including location and time period."""
    themes: list[str] # changed to list[str] to remove need for import
    """List of major themes explored in the novel, particularly dark and erotic themes."""
    tone: str
    """The overall tone of the novel (e.g., gritty, suspenseful, sensual, melancholic)."""
    point_of_view: str
    """The narrative point of view (e.g., first-person, third-person limited, third-person omniscient)."""
    characters: list[str] # changed to list[str] to remove need for import
    """Detailed descriptions of 2-3 main characters, including motivations and flaws related to dark and erotic elements."""
    premise: str
    """A concise and intriguing premise that sets up the central conflict and hints at the dark and erotic nature of the story."""
```````

`/home/tlh/refactored_gui_fict_fab/core/plot_outline.py`:

```````py
# core/plot_outline.py
from pydantic import BaseModel


class PlotOutline(BaseModel):
    """
    Represents a three-act plot outline for a novel.

    This Pydantic model defines the structure for storing the three acts
    of a plot outline: Act One (Setup), Act Two (Confrontation), and
    Act Three (Resolution). Each act is represented as a string containing
    a summary of the plot points within that act.
    """

    act_one: str
    """Summary of Act One: Setup - Introduction of characters, setting, and initial conflict."""
    act_two: str
    """Summary of Act Two: Confrontation - Development of conflict, rising stakes, and obstacles."""
    act_three: str
    """Summary of Act Three: Resolution - Climax, resolution of conflict, and thematic closure."""


class ChapterOutline(BaseModel):
    """
    Represents an outline for a single chapter in the novel.

    This Pydantic model defines the structure for a chapter outline,
    including the chapter number and a summary of the chapter's events.
    """

    chapter_number: int
    """The chapter number (e.g., 1, 2, 3...)."""
    summary: str
    """A summary of the key events and developments within this chapter."""


class SceneOutline(BaseModel):
    """
    Represents an outline for a single scene within a chapter.

    This Pydantic model defines the structure for a scene outline,
    including the scene number and a summary of the scene's events,
    setting, and characters involved.
    """

    scene_number: int
    """The scene number within the chapter (e.g., 1, 2, 3...)."""
    summary: str
    """A summary of the key events, setting, and characters in this scene."""

```````

`/home/tlh/refactored_gui_fict_fab/core/project_manager.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/core/project_manager.py
import json
import os
from typing import Dict, Any, Optional

from utils.file_handler import save_json, load_json
from utils.config import config
from utils.logger import logger


class ProjectManager:
    """
    Manages project-related operations such as saving and loading project data.
    """

    def __init__(self):
        """
        Initializes the ProjectManager with the project directory from config.
        """
        self.project_dir = config.get_project_directory()
        os.makedirs(self.project_dir, exist_ok=True)  # Ensure project directory exists
        logger.debug(
            f"ProjectManager initialized, project directory: {self.project_dir}"
        )

    def save_project(
        self,
        project_name: str,
        story_idea: str,
        book_spec: Any,  # BookSpec | None,
        plot_outline: Any,  # PlotOutline | None,
        chapter_outlines: list[Any],  # list[ChapterOutline] | None,
        scene_outlines: Dict[int, list[Any]],  # Dict[int, list[SceneOutline]] | None,
        scene_parts: Dict[int, Dict[int, Any]],  # Dict[int, Dict[int, str]] | None,
        scene_parts_text: Dict[int, Dict[int, Dict[int, str]]],
        book_text: Optional[str],
    ) -> None:
        """
        Saves the project data to a JSON file.
        """
        # Enforce lowercase project directory names:
        project_dir_name = (
            project_name.lower()
        )  # Convert project name to lowercase for directory
        project_dir = os.path.join(
            self.project_dir, project_dir_name
        )  # Use lowercase name for directory
        os.makedirs(project_dir, exist_ok=True)  # Create project folder if not exists
        project_filepath = os.path.join(
            project_dir, f"{project_name}.json"
        )  # Filename still uses original project_name

        logger.debug(f"Saving project '{project_name}', filepath: {project_filepath}")

        try:
            # Convert Pydantic models to dictionaries
            book_spec_data = book_spec.model_dump() if book_spec else None
            plot_outline_data = plot_outline.model_dump() if plot_outline else None
            chapter_outlines_data = (
                [co.model_dump() for co in chapter_outlines]
                if chapter_outlines
                else None
            )
            scene_outlines_data = (
                {
                    chapter_num: [so.model_dump() for so in scene_outlines]
                    for chapter_num, scene_outlines in scene_outlines.items()
                }
                if scene_outlines
                else None
            )

            project_data: Dict[str, Any] = {
                "story_idea": story_idea,
                "book_spec": book_spec_data,
                "plot_outline": plot_outline_data,
                "chapter_outlines": chapter_outlines_data,
                "scene_outlines": scene_outlines_data,
                "scene_parts": scene_parts,
                "scene_parts_text": scene_parts_text,
                "book_text": book_text,
            }
            logger.debug(f"Project data before save_json: {project_data}")

            save_json(project_data, project_filepath)
            logger.info("Project '%s' saved successfully.", project_name)
        except Exception as e:
            logger.error("Error saving project '%s': %s", project_name, e)
            raise

    def load_project(self, project_name: str) -> Optional[Dict[str, Any]]:
        """
        Loads project data from a JSON file.
        """
        # Enforce lowercase project directory names for loading as well:
        project_dir_name = (
            project_name.lower()
        )  # Convert project name to lowercase for directory
        project_dir = os.path.join(
            self.project_dir, project_dir_name
        )  # Use lowercase directory name
        project_filepath = os.path.join(
            project_dir, f"{project_name}.json"
        )  # Filename still uses original project_name

        logger.debug(f"Loading project '{project_name}', filepath: {project_filepath}")

        if not os.path.exists(project_filepath):
            logger.error(f"Project file NOT found at: {project_filepath}")
            raise FileNotFoundError(f"Project file not found: {project_filepath}")

        if not os.path.isfile(project_filepath):
            logger.error(f"Path is not a file: {project_filepath}")
            raise FileNotFoundError(f"Project file is not a file: {project_filepath}")

        try:
            project_data = load_json(project_filepath)
            logger.info("Project '%s' loaded successfully.", project_name)
            logger.debug(f"Project data after load_json: {project_data}")
            return project_data
        except FileNotFoundError:
            logger.error(f"Project file not found: %s", project_filepath)
            raise
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding JSON from %s: %s", project_filepath, e)
            raise
        except Exception as e:
            logger.error(f"Error loading project '%s': %s", project_name, e)
            raise

```````

`/home/tlh/refactored_gui_fict_fab/flake.nix`:

```````nix
{
  description = "A basic flake demoing a python wrapper with lib injection";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
  };

  outputs = {
    self,
    nixpkgs,
  }: let
    supportedSystems = ["x86_64-linux"];
    forAllSystems = nixpkgs.lib.genAttrs supportedSystems;
    pkgs = forAllSystems (system: import nixpkgs {inherit system;});
    pythonVer = "311";
  in {
    packages = {};

    devShells = forAllSystems (system:
      with pkgs.${system}; let
        python = pkgs.${system}."python${pythonVer}";
        wrappedPython = writeShellScriptBin "python" ''
          export LD_LIBRARY_PATH=$NIX_LD_LIBRARY_PATH
          SCRIPT_DIR=$(${coreutils}/bin/dirname $(${coreutils}/bin/realpath -s "$0"))
          exec -a "$SCRIPT_DIR/python" "${python}/bin/python" "$@"
        '';
      in
        with pkgs.${system}; {
          default = pkgs.${system}.mkShell {
            # adapt to your needs
            NIX_LD_LIBRARY_PATH =
              lib.makeLibraryPath [stdenv.cc.cc openssl zlib];
            packages = [wrappedPython];
          };
        });
  };
}

```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/book_spec_prompts.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/book_spec_prompts.py
from llm.prompt_manager.base_prompts import (
    COMMON_INSTRUCTIONS_NOVELIST,
    STRUCTURE_CHECK_INSTRUCTIONS,
    STRUCTURE_FIX_PROMPT_TEMPLATE,
    CRITIQUE_PROMPT_TEMPLATE,
    REWRITE_PROMPT_TEMPLATE,
)
from core.book_spec import BookSpec
import json


class BookSpecPrompts:
    """
    Encapsulates prompt templates for BookSpec operations, loading templates from files.
    """

    def __init__(self, prompt_manager, template_env):
        """
        Initializes BookSpecPrompts with a reference to the prompt manager and Jinja2 environment.
        """
        self.prompt_manager = prompt_manager
        self.template_env = template_env

    def get_prompt(self, prompt_name: str) -> str:
        """
        Retrieves and renders a specific BookSpec prompt by name from a Jinja2 template file.

        Args:
            prompt_name (str): The name of the prompt to retrieve (e.g., 'book_spec_generation_prompt').

        Returns:
            str: The rendered prompt text.
        """
        template_name = f"{prompt_name}.j2"  # Filename convention: prompt_name.j2
        template = self.template_env.get_template(template_name)  # Load template from file

        if prompt_name == "book_spec_generation_prompt":
            json_schema = BookSpec.model_json_schema()  # Get BookSpec JSON schema
            variables = {"json_structure": json.dumps(json_schema, indent=4), "BookSpec_json_schema": json.dumps(BookSpec.model_json_schema(), indent=4)}  # Pass schema as variable
        elif prompt_name == "book_spec_structure_fix_prompt":
            json_schema = BookSpec.model_json_schema()  # Get BookSpec JSON schema
            variables = {"json_structure": json.dumps(json_schema, indent=4), "BookSpec_json_schema": json.dumps(BookSpec.model_json_schema(), indent=4)}  # Pass schema as variable
        else:
            variables = {}  # Default to empty variables for other prompts

        return template.render(
            COMMON_INSTRUCTIONS_NOVELIST=COMMON_INSTRUCTIONS_NOVELIST,
            STRUCTURE_CHECK_INSTRUCTIONS=STRUCTURE_CHECK_INSTRUCTIONS,
            STRUCTURE_FIX_PROMPT_TEMPLATE=STRUCTURE_FIX_PROMPT_TEMPLATE,
            CRITIQUE_PROMPT_TEMPLATE=CRITIQUE_PROMPT_TEMPLATE,
            REWRITE_PROMPT_TEMPLATE=REWRITE_PROMPT_TEMPLATE,
            **variables,
        )  # Pass base templates and stage-specific variables

    def create_book_spec_generation_prompt(self) -> str:
        """
        Proxies to get_prompt for 'book_spec_generation_prompt' to use template files.
        """
        return self.get_prompt("book_spec_generation_prompt")

    def create_book_spec_structure_check_prompt(self) -> str:
        """
        Proxies to get_prompt for 'book_spec_structure_check_prompt'.
        """
        return self.get_prompt("book_spec_structure_check_prompt")

    def create_book_spec_structure_fix_prompt(self) -> str:
        """
        Proxies to get_prompt for 'book_spec_structure_fix_prompt'.
        """
        return self.get_prompt("book_spec_structure_fix_prompt")

    def create_book_spec_critique_prompt(self) -> str:
        """
        Proxies to get_prompt for 'book_spec_critique_prompt'.
        """
        return self.get_prompt("book_spec_critique_prompt")

    def create_book_spec_rewrite_prompt(self) -> str:
        """
        Proxies to get_prompt for 'book_spec_rewrite_prompt'.
        """
        return self.get_prompt("book_spec_rewrite_prompt")
```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/scene_part_prompts.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/scene_part_prompts.py
# llm/prompt_manager/scene_part_prompts.py

"""
Prompt templates for ScenePart generation and enhancement.

This module defines the prompt templates used by the ScenePartGenerator
to generate and enhance ScenePart objects. It utilizes base templates
from base_prompts.py for consistency and reduced redundancy.
"""

from llm.prompt_manager.base_prompts import (
    COMMON_INSTRUCTIONS_NOVELIST,
    STRUCTURE_CHECK_INSTRUCTIONS,
    STRUCTURE_FIX_PROMPT_TEMPLATE,
    CRITIQUE_PROMPT_TEMPLATE,
    REWRITE_PROMPT_TEMPLATE,
)
from core.book_spec import BookSpec # Import BookSpec
from core.plot_outline import ChapterOutline, SceneOutline # Import ChapterOutline, SceneOutline
import json # Import json


class ScenePartPrompts:
    """
    Encapsulates prompt templates for ScenePart operations.

    Provides methods to retrieve specific prompt templates for
    generating, structure checking, fixing, critiquing, and rewriting SceneParts.
    """

    def __init__(self, prompt_manager=None):
        """
        Initializes ScenePartPrompts.
        Prompt manager is currently not used, but included for potential future use or consistency.
        """
        self.template_env = None
        self.prompt_manager = prompt_manager

    def get_prompt(self, prompt_name: str) -> str:
        """
        Returns the prompt template for generating SceneParts from SceneOutline.
        """
        json_structure = BookSpec.model_json_schema() # Using BookSpec schema as it's comprehensive enough
        template_name = f"{prompt_name}.j2" # Filename convention: prompt_name.j2
        template = self.template_env.get_template(template_name) # Load template from file
        variables = {"json_structure": json.dumps(json_structure, indent=4)}
        return template.render(COMMON_INSTRUCTIONS_NOVELIST=COMMON_INSTRUCTIONS_NOVELIST, 
                                STRUCTURE_CHECK_INSTRUCTIONS=STRUCTURE_CHECK_INSTRUCTIONS,
                                STRUCTURE_FIX_PROMPT_TEMPLATE=STRUCTURE_FIX_PROMPT_TEMPLATE,
                                CRITIQUE_PROMPT_TEMPLATE=CRITIQUE_PROMPT_TEMPLATE,
                                REWRITE_PROMPT_TEMPLATE=REWRITE_PROMPT_TEMPLATE,
                                json_structure = json.dumps(json_structure, indent=4)
                                )

    def create_scene_part_generation_prompt(self) -> str:
        """
        Returns the prompt template for generating SceneParts.
        """
        return self.get_prompt("scene_part_generation_prompt")

    def create_scene_part_structure_check_prompt(self) -> str:
        """
        Returns the prompt template for checking the structure of SceneParts.
        """
        return self.get_prompt("scene_part_structure_check_prompt")

    def create_scene_part_structure_fix_prompt(self) -> str:
        """
        Returns the prompt template for fixing structural issues in SceneParts.
        """
        return self.get_prompt("scene_part_structure_fix_prompt")

    def create_scene_part_critique_prompt(self) -> str:
        """
        Returns the prompt template for generating a critique of SceneParts.
        """
        return self.get_prompt("scene_part_critique_prompt")

    def create_scene_part_rewrite_prompt(self) -> str:
        """
        Returns the prompt template for rewriting SceneParts.
        """
        return self.get_prompt("scene_part_rewrite_prompt")
```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/base_prompts.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/base_prompts.py
"""
Base prompt templates and utility functions for prompt management.

This module defines common prompt snippets and helper functions
that are reused across different prompt modules to ensure consistency and
reduce redundancy in prompt definitions.
"""

COMMON_INSTRUCTIONS_NOVELIST = """
You are a world-class novelist, skilled in crafting compelling narratives
with rich detail and engaging prose. Your expertise lies in generating
high-quality, long-form fictional content based on provided specifications.
Your goal is to produce creative and well-structured outputs that adhere
to all instructions and specifications given.
"""

STRUCTURE_CHECK_INSTRUCTIONS = """
You are a meticulous editor, expert in ensuring that generated content
adheres to a specific structure and format. Your task is to review the
content provided and verify if it correctly follows the required structure.
If the structure is correct, you should respond with 'STRUCTURE_OK'.
If there are structural issues, you must provide a detailed explanation
of the problems and clearly indicate how to fix them. Be specific and actionable in your feedback.
"""

CRITIQUE_PROMPT_TEMPLATE = """
You are a world-class editor, providing concise and actionable feedback
to improve the quality and structure of the provided content.
Your goal is to identify specific areas for improvement and offer
constructive criticism that will guide the writer to enhance their work.

Please provide a critique of the following content:
```
{content}
```

Your critique should be:
- **Concise:**  Limited to 2-3 sentences maximum.
- **Actionable:** Focus on specific, concrete areas for improvement.
- **Constructive:**  Frame feedback in a positive and encouraging tone.
- **Focused:** Address aspects such as clarity, detail, coherence, pacing,
  narrative flow, character development (if applicable), and thematic resonance.
"""

REWRITE_PROMPT_TEMPLATE = """
You are a world-class novelist, now acting as a reviser, tasked with
improving and refining the provided content based on editor feedback.
Your goal is to rewrite the content, addressing the critique provided
and enhancing its overall quality, impact, and adherence to the project's specifications.

Here is the content to be revised:
```
{content}
```

Here is the editor's critique:
```
{critique}
```

Based on the critique, rewrite the content to address the identified issues
and enhance its strengths. Focus on:
- Directly responding to the critique points.
- Improving clarity, detail, and engagement.
- Strengthening the narrative, pacing, and thematic elements.
- Ensuring the rewritten content is of the highest possible quality and
  effectively serves its purpose within the overall project.
"""

STRUCTURE_FIX_PROMPT_TEMPLATE = """
You are a meticulous editor tasked with fixing structural issues in a BookSpec object.

Here is the flawed BookSpec in JSON format:
```json
{content_with_structure_problems}
```

Here is a detailed list of structural problems and how to fix them:
```
{structure_problems}
```

Your task is to modify the JSON to adhere to the correct structure as outlined below:

```json
{json_structure}
```

Return only valid JSON, without deviations or extra explanation. Adhere strictly to this format, ensuring correct data types and escaping.
"""

```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/plot_outline_prompts.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/plot_outline_prompts.py
# llm/prompt_manager/plot_outline_prompts.py

"""
Prompt templates for PlotOutline generation and enhancement.

This module defines the prompt templates used by the PlotOutlineGenerator
to generate and enhance PlotOutline objects. It utilizes base templates
from base_prompts.py for consistency and reduced redundancy.
"""

from llm.prompt_manager.base_prompts import (
    COMMON_INSTRUCTIONS_NOVELIST,
    STRUCTURE_CHECK_INSTRUCTIONS,
    STRUCTURE_FIX_PROMPT_TEMPLATE,
    CRITIQUE_PROMPT_TEMPLATE,
    REWRITE_PROMPT_TEMPLATE,
)
from core.plot_outline import PlotOutline  # Import PlotOutline
import json  # Import json


class PlotOutlinePrompts:
    """
    Encapsulates prompt templates for PlotOutline operations.

    Provides methods to retrieve specific prompt templates for
    generating, structure checking, fixing, critiquing, and rewriting PlotOutlines.
    """

    def __init__(self, prompt_manager=None):
        """
        Initializes PlotOutlinePrompts.
        Prompt manager is currently not used, but included for potential future use or consistency.
        """
        self.prompt_manager = prompt_manager  # Currently not used
        self.template_env = None

    def get_prompt(self, prompt_name: str) -> str:
        """
        Returns the prompt template for generating a PlotOutline from a BookSpec.
        """
        json_structure = PlotOutline.model_json_schema()  # Get schema as Python dict
        template_name = f"{prompt_name}.j2"  # Filename convention: prompt_name.j2
        template = self.template_env.get_template(
            template_name
        )  # Load template from file
        variables = {"json_structure": json.dumps(json_structure, indent=4)}
        return template.render(
            COMMON_INSTRUCTIONS_NOVELIST=COMMON_INSTRUCTIONS_NOVELIST,
            STRUCTURE_CHECK_INSTRUCTIONS=STRUCTURE_CHECK_INSTRUCTIONS,
            STRUCTURE_FIX_PROMPT_TEMPLATE=STRUCTURE_FIX_PROMPT_TEMPLATE,
            CRITIQUE_PROMPT_TEMPLATE=CRITIQUE_PROMPT_TEMPLATE,
            REWRITE_PROMPT_TEMPLATE=REWRITE_PROMPT_TEMPLATE,
            json_structure=json.dumps(json_structure, indent=4),
        )

    def create_plot_outline_generation_prompt(self) -> str:
        """
        Returns the prompt template for generating a PlotOutline from a BookSpec.
        """
        return self.get_prompt("plot_outline_generation_prompt")

    def create_plot_outline_structure_check_prompt(self) -> str:
        """
        Returns the prompt template for checking the structure of a PlotOutline.
        """
        return self.get_prompt("plot_outline_structure_check_prompt")

    def create_plot_outline_structure_fix_prompt(self) -> str:
        """
        Returns the prompt template for fixing structural issues in a PlotOutline.
        """
        return self.get_prompt("plot_outline_structure_fix_prompt")

    def create_plot_outline_critique_prompt(self) -> str:
        """
        Returns the prompt template for generating a critique of a PlotOutline.
        """
        return self.get_prompt("plot_outline_critique_prompt")

    def create_plot_outline_rewrite_prompt(self) -> str:
        """
        Returns the prompt template for rewriting a PlotOutline based on critique.
        """
        return self.get_prompt("plot_outline_rewrite_prompt")

```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/chapter_outline_prompts.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/chapter_outline_prompts.py
# llm/prompt_manager/chapter_outline_prompts.py

"""
Prompt templates for ChapterOutline generation and enhancement.

This module defines the prompt templates used by the ChapterOutlineGenerator
to generate and enhance ChapterOutline objects. It utilizes base templates
from base_prompts.py for consistency and reduced redundancy.
"""

from llm.prompt_manager.base_prompts import (
    COMMON_INSTRUCTIONS_NOVELIST,
    STRUCTURE_CHECK_INSTRUCTIONS,
    STRUCTURE_FIX_PROMPT_TEMPLATE,
    CRITIQUE_PROMPT_TEMPLATE,
    REWRITE_PROMPT_TEMPLATE,
)
from core.plot_outline import ChapterOutline  # Import ChapterOutline
import json  # Import json


class ChapterOutlinePrompts:
    """
    Encapsulates prompt templates for ChapterOutline operations.

    Provides methods to retrieve specific prompt templates for
    generating, structure checking, fixing, critiquing, and rewriting ChapterOutlines.
    """

    def __init__(self, prompt_manager=None):
        """
        Initializes ChapterOutlinePrompts.
        Prompt manager is currently not used, but included for potential future use or consistency.
        """
        self.prompt_manager = prompt_manager
        self.template_env = None

    def get_prompt(self, prompt_name: str) -> str:
        """
        Returns the prompt template for generating ChapterOutlines from a PlotOutline.
        """
        json_structure = ChapterOutline.model_json_schema()  # Get schema as Python dict
        template_name = f"{prompt_name}.j2"  # Filename convention: prompt_name.j2
        template = self.template_env.get_template(
            template_name
        )  # Load template from file
        variables = {"json_structure": json.dumps(json_structure, indent=4)}
        return template.render(
            COMMON_INSTRUCTIONS_NOVELIST=COMMON_INSTRUCTIONS_NOVELIST,
            STRUCTURE_CHECK_INSTRUCTIONS=STRUCTURE_CHECK_INSTRUCTIONS,
            STRUCTURE_FIX_PROMPT_TEMPLATE=STRUCTURE_FIX_PROMPT_TEMPLATE,
            CRITIQUE_PROMPT_TEMPLATE=CRITIQUE_PROMPT_TEMPLATE,
            REWRITE_PROMPT_TEMPLATE=REWRITE_PROMPT_TEMPLATE,
            json_structure=json.dumps(json_structure, indent=4),
        )

    def create_chapter_outlines_generation_prompt(self) -> str:
        """
        Returns the prompt template for generating ChapterOutlines from a PlotOutline.
        """
        return self.get_prompt("chapter_outlines_generation_prompt")

    def create_chapter_outlines_structure_check_prompt(self) -> str:
        """
        Returns the prompt template for checking the structure of ChapterOutlines.
        """
        return self.get_prompt("chapter_outlines_structure_check_prompt")

    def create_chapter_outlines_structure_fix_prompt(self) -> str:
        """
        Returns the prompt template for fixing structural issues in ChapterOutlines.
        """
        return self.get_prompt("chapter_outlines_structure_fix_prompt")

    def create_chapter_outlines_critique_prompt(self) -> str:
        """
        Returns the prompt template for generating a critique of ChapterOutlines.
        """
        return self.get_prompt("chapter_outlines_critique_prompt")

    def create_chapter_outlines_rewrite_prompt(self) -> str:
        """
        Returns the prompt template for rewriting ChapterOutlines based on critique.
        """
        return self.get_prompt("chapter_outlines_rewrite_prompt")

```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/prompt_manager.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/prompt_manager.py
import logging
from typing import Dict, Protocol, runtime_checkable

from utils.logger import logger  # Assuming you have a logger configured

from llm.prompt_manager.book_spec_prompts import BookSpecPrompts
from llm.prompt_manager.plot_outline_prompts import PlotOutlinePrompts
from llm.prompt_manager.chapter_outline_prompts import ChapterOutlinePrompts
from llm.prompt_manager.scene_outline_prompts import SceneOutlinePrompts
from llm.prompt_manager.scene_part_prompts import ScenePartPrompts


@runtime_checkable
class PromptManagerInterface(Protocol):
    """
    Defines the interface for PromptManager classes.
    """

    """
    Retrieves a specific prompt by its name.

    Args:
        prompt_name (str): The name identifier of the prompt to retrieve.

    Returns:
        str: The requested prompt text.

    Raises:
        NotImplementedError: This is an abstract method that must be implemented by subclasses.
    """

    def get_prompt(self, prompt_name: str) -> str: ...  # Abstract method


class DynamicPromptManager(PromptManagerInterface):
    """
    Manages prompts dynamically, delegating to specialized prompt classes.
    """

    def __init__(self):
        """
        Initializes the DynamicPromptManager, creating instances of specialized prompt handlers.
        """
        self.book_spec_prompts = BookSpecPrompts(self)
        self.plot_outline_prompts = PlotOutlinePrompts(self)
        self.chapter_outline_prompts = ChapterOutlinePrompts(self)
        self.scene_outline_prompts = SceneOutlinePrompts(self)
        self.scene_part_prompts = ScenePartPrompts(self)

    def get_prompt(self, prompt_name: str) -> str:
        """
        Retrieves a prompt by name, delegating the call to the appropriate specialized prompt handler.

        Args:
            prompt_name (str): The name of the prompt to retrieve.

        Returns:
            str: The prompt text from the relevant prompt handler.
        """
        logger.debug(f"Fetching prompt: {prompt_name}")
        if prompt_name.startswith("book_spec"):
            return self.book_spec_prompts.get_prompt(prompt_name)
        elif prompt_name.startswith("plot_outline"):
            return self.plot_outline_prompts.get_prompt(prompt_name)
        elif prompt_name.startswith("chapter_outlines"):
            return self.chapter_outline_prompts.get_prompt(prompt_name)
        elif prompt_name.startswith("scene_outlines"):
            return self.scene_outline_prompts.get_prompt(prompt_name)
        elif prompt_name.startswith("scene_part"):
            return self.scene_part_prompts.get_prompt(prompt_name)
        else:
            logger.error(f"Prompt name not recognized: {prompt_name}")
            raise ValueError(f"Prompt name not recognized: {prompt_name}")

```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/scene_outline_prompts.py`:

```````py
# /home/tlh/refactored_gui_fict_fab/llm/prompt_manager/scene_outline_prompts.py
# llm/prompt_manager/scene_outline_prompts.py

"""
Prompt templates for SceneOutline generation and enhancement.

This module defines the prompt templates used by the SceneOutlineGenerator
to generate and enhance SceneOutline objects. It utilizes base templates
from base_prompts.py for consistency and reduced redundancy.
"""

from llm.prompt_manager.base_prompts import (
    COMMON_INSTRUCTIONS_NOVELIST,
    STRUCTURE_CHECK_INSTRUCTIONS,
    STRUCTURE_FIX_PROMPT_TEMPLATE,
    CRITIQUE_PROMPT_TEMPLATE,
    REWRITE_PROMPT_TEMPLATE,
)
from core.plot_outline import SceneOutline  # Import SceneOutline
import json  # Import json


class SceneOutlinePrompts:
    """
    Encapsulates prompt templates for SceneOutline operations.

    Provides methods to retrieve specific prompt templates for
    generating, structure checking, fixing, critiquing, and rewriting SceneOutlines.
    """

    def __init__(self, prompt_manager=None):
        """
        Initializes SceneOutlinePrompts.
        Prompt manager is currently not used, but included for potential future use or consistency.
        """
        self.prompt_manager = prompt_manager
        self.template_env = None

    def get_prompt(self, prompt_name: str) -> str:
        """
        Returns the prompt template for generating SceneOutlines from a ChapterOutline.
        """
        json_structure = SceneOutline.model_json_schema()  # Get schema as Python dict
        template_name = f"{prompt_name}.j2"  # Filename convention: prompt_name.j2
        template = self.template_env.get_template(
            template_name
        )  # Load template from file
        variables = {"json_structure": json.dumps(json_structure, indent=4)}
        return template.render(
            COMMON_INSTRUCTIONS_NOVELIST=COMMON_INSTRUCTIONS_NOVELIST,
            STRUCTURE_CHECK_INSTRUCTIONS=STRUCTURE_CHECK_INSTRUCTIONS,
            STRUCTURE_FIX_PROMPT_TEMPLATE=STRUCTURE_FIX_PROMPT_TEMPLATE,
            CRITIQUE_PROMPT_TEMPLATE=CRITIQUE_PROMPT_TEMPLATE,
            REWRITE_PROMPT_TEMPLATE=REWRITE_PROMPT_TEMPLATE,
            json_structure=json.dumps(json_structure, indent=4),
        )

    def create_scene_outlines_generation_prompt(self) -> str:
        """
        Returns the prompt template for generating SceneOutlines from a ChapterOutline.
        """
        return self.get_prompt("scene_outlines_generation_prompt")

    def create_scene_outlines_structure_check_prompt(self) -> str:
        """
        Returns the prompt template for checking the structure of SceneOutlines.
        """
        return self.get_prompt("scene_outlines_structure_check_prompt")

    def create_scene_outlines_structure_fix_prompt(self) -> str:
        """
        Returns the prompt template for fixing structural issues in SceneOutlines.
        """
        return self.get_prompt("scene_outlines_structure_fix_prompt")

    def create_scene_outlines_critique_prompt(self) -> str:
        """
        Returns the prompt template for generating a critique of SceneOutlines.
        """
        return self.get_prompt("scene_outlines_critique_prompt")

    def create_scene_outlines_rewrite_prompt(self) -> str:
        """
        Returns the prompt template for rewriting SceneOutlines based on critique.
        """
        return self.get_prompt("scene_outlines_rewrite_prompt")

```````

`/home/tlh/refactored_gui_fict_fab/llm/prompt_manager/__init__.py`:

```````py
# llm/prompt_manager/__init__.py

"""
Package initializer for the prompt_manager package.

This package is dedicated to managing and organizing prompts for
the Fiction Fabricator application. It includes modules for:

- base_prompts.py: Defines common prompt templates and potentially 
  utility functions shared across different prompt modules.
- book_spec_prompts.py: Contains prompt templates specifically for 
  generating and enhancing BookSpec objects.
- plot_outline_prompts.py: Contains prompt templates for generating and 
  enhancing PlotOutline objects.
- chapter_outline_prompts.py: Contains prompt templates for generating and 
  enhancing ChapterOutline objects.
- scene_outline_prompts.py: Contains prompt templates for generating and 
  enhancing SceneOutline objects.
- scene_part_prompts.py: Contains prompt templates for generating and 
  enhancing ScenePart objects.

Each module within this package is responsible for encapsulating the 
prompts related to a specific content generation stage, promoting 
organization and maintainability of the prompt engineering aspects 
of the application.
"""
```````

`/home/tlh/refactored_gui_fict_fab/llm/llm_client.py`:

```````py
# llm/llm_client.py

from typing import Optional


import requests  # Import the requests library

from utils.config import config
from utils.logger import logger
from openai import (
    AsyncOpenAI,
    types,
    APIError,
    APIConnectionError,
    RateLimitError,
)  # Import error types


class OpenAILLMClient:
    """
    Client for interacting with a local OpenAI compatible instance.
    """

    def __init__(self, base_url: str = None):
        """
        Initializes the OpenAI client.
        """
        self.base_url = base_url or config.get_openai_base_url()
        self.client = AsyncOpenAI(
            base_url=self.base_url, api_key="placeholder"
        )  # Initialize OpenAI client
        logger.debug("OpenAILLMClient initialized with base_url: %s", self.base_url)

    async def list_models(self) -> Optional[list[str]]:
        """
        Asynchronously fetches the list of available models from the OpenAI API.
        Falls back to requests if openai library fails.
        """
        try:
            response = await self.client.models.list()
            model_names = [
                model.id for model in response.data if isinstance(model, types.Model)
            ]  # Use types.Model
            logger.info(
                "Successfully fetched models using openai library: {model_names}"
            )
            return model_names
        except (APIError, APIConnectionError, RateLimitError) as openai_err:
            logger.warning(
                f"Error fetching models using openai library: {openai_err}. Trying requests fallback."
            )
            try:
                url = f"{self.base_url}/models"  # Standard models endpoint
                response = requests.get(url, timeout=0)
                response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
                data = response.json()
                # Adjust key based on typical API responses; 'data' or 'models' are common
                models_data = data.get("data") or data.get("models", [])
                model_names = [
                    model["id"]
                    for model in models_data
                    if isinstance(model, dict) and "id" in model
                ]
                logger.info("Successfully fetched models using requests: {model_names}")
                return model_names
            except requests.RequestException as requests_err:
                logger.error(
                    "Error fetching models using requests fallback: {requests_err}"
                )
                return None

    async def generate_text(self, model_name: str, prompt: str) -> Optional[str]:
        """
        Asynchronously generates text using the OpenAI API.
        """
        try:
            response = await self.client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": prompt},
                ],
                temperature=0.7,
                max_tokens=800,
            )
            generated_text = response.choices[0].message.content

            if generated_text:
                logger.info("Text generated successfully using model '{model_name}'")
                return generated_text
            else:
                logger.error("No response from OpenAI API")
                return None

        except (
            APIError,
            APIConnectionError,
            RateLimitError,
        ) as e:  # Catch specific OpenAI errors
            logger.error("OpenAI text generation failed: {e}")
            return None

```````

`/home/tlh/refactored_gui_fict_fab/llm/__init__.py`:

```````py
"""
llm package initializer.

This package contains modules for interacting with Language Models,
specifically Ollama in this project. It includes:

    llm_client.py: Defines the OllamaClient for making API calls to Ollama.

    prompt_manager/: A directory containing modules for managing and
    organizing prompts used for different content generation stages.

"""
```````